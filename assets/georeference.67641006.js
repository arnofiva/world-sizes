import{ai as G,kS as j,iy as V,df as C,k7 as D,kT as W,kU as I,a as p,d as g,n as Z,en as H,al as N,hz as J,ke as X,kV as K,kW as Q,dj as P,cZ as m,dm as z,kX as h,d8 as _,cY as B,e1 as tt,kY as d,ba as nt,kZ as rt,k_ as et,k$ as at,aS as ot,r as M,l0 as it,l1 as lt,jU as w,jI as st,l2 as ct,l3 as Y,t as f,l4 as x,l5 as y,l6 as ut,l7 as pt,l8 as gt,ad as ft,j6 as ht,dl as yt,l9 as mt,la as $t,lb as At,lc as dt,ld as xt,le as Tt}from"./vendor.f59113c8.js";function $(t=wt){return[t[0],t[1],t[2],t[3]]}function Yt(t,r,n=$()){return G(n,t),n[3]=r,n}function qt(t,r,n=$()){return j(A,t,F(t)),j(L,r,F(r)),C(A,L,A),vt(n,D(W(n,A)))}function Ot(t){return t}function F(t){return V(t[3])}function vt(t,r){return t[3]=r,t}const wt=[0,0,1,0],A=I(),L=I();$();var R;let u=R=class extends H{constructor(t){super(t),this.origin=N(),this.translation=N(),this.rotation=$(),this.scale=J(1,1,1),this.geographic=!0}get localMatrix(){const t=m();return X(t,this.scale),K(t,t,F(this.rotation),this.rotation),Q(t,t,this.translation),t}get localMatrixInverse(){return P(m(),this.localMatrix)}applyLocal(t,r){return z(r,t,this.localMatrix)}applyLocalInverse(t,r){return z(r,t,this.localMatrixInverse)}project(t,r){const n=new Float64Array(t.length),e=h.fromTypedArray(n),a=h.fromTypedArray(t);if(this.geographic){const l=_(r),c=m();return B(r,this.origin,c,l),tt(c,c,this.localMatrix),d(e,a,c),nt(n,l,0,n,r,0,n.length/3),n}const{localMatrix:o,origin:i}=this;rt(o,et)?at(e,a):d(e,a,o);for(let l=0;l<n.length;l+=3)n[l+0]+=i[0],n[l+1]+=i[1],n[l+2]+=i[2];return n}getOriginPoint(t){const[r,n,e]=this.origin;return new ot({x:r,y:n,z:e,spatialReference:t})}equals(t){return M(t)&&this.geographic===t.geographic&&it(this.origin,t.origin)&&lt(this.localMatrix,t.localMatrix)}clone(){const t={origin:w(this.origin),translation:w(this.translation),rotation:$(this.rotation),scale:w(this.scale),geographic:this.geographic};return new R(t)}};p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"origin",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"translation",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"rotation",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"scale",void 0),p([g({type:Boolean,nonNullable:!0,json:{write:!0}})],u.prototype,"geographic",void 0),p([g()],u.prototype,"localMatrix",null),p([g()],u.prototype,"localMatrixInverse",null),u=R=p([Z("esri.geometry.support.MeshTransform")],u);const Mt=u;function T(t,r){var n;return t.isGeographic||t.isWebMercator&&((n=r==null?void 0:r.geographic)==null||n)}function q(t,r,n){return T(r.spatialReference,n)?kt(t,r,n):bt(t,r,n)}function Ft(t,r,n){const{position:e,normal:a,tangent:o}=t;if(f(r))return{position:e,normal:a,tangent:o};const i=r.localMatrix;return q({position:dt(e,new Float64Array(e.length),i),normal:M(a)?xt(a,new Float32Array(a.length),i):null,tangent:M(o)?Tt(o,new Float32Array(o.length),i):null},r.getOriginPoint(n),{geographic:r.geographic})}function St(t,r,n){if(n!=null&&n.useTransform){var e;const{position:a,normal:o,tangent:i}=t;return{vertexAttributes:{position:a,normal:o,tangent:i},transform:new Mt({origin:[r.x,r.y,(e=r.z)!=null?e:0],geographic:T(r.spatialReference,n)})}}return{vertexAttributes:q(t,r,n),transform:null}}function Rt(t,r,n){return T(r.spatialReference,n)?O(t,r,n):b(t,r,n)}function Ut(t,r,n,e){if(f(r))return Rt(t,n,e);const a=Ft(t,r,n.spatialReference);return n.equals(r.getOriginPoint(n.spatialReference))?b(a,n,e):T(n.spatialReference,e)?O(a,n,e):b(a,n,e)}function bt(t,r,n){const e=new Float64Array(t.position.length),a=t.position,o=r.x,i=r.y,l=r.z||0,{horizontal:c,vertical:v}=E(n?n.unit:null,r.spatialReference);for(let s=0;s<a.length;s+=3)e[s+0]=a[s+0]*c+o,e[s+1]=a[s+1]*c+i,e[s+2]=a[s+2]*v+l;return{position:e,normal:t.normal,tangent:t.tangent}}function kt(t,r,n){const e=r.spatialReference,a=S(r,n,k),o=new Float64Array(t.position.length),i=Et(t.position,a,e,o),l=Y(U,a);return{position:i,normal:jt(i,o,t.normal,l,e),tangent:Nt(i,o,t.tangent,l,e)}}function Et(t,r,n,e){d(h.fromTypedArray(e),h.fromTypedArray(t),r);const a=new Float64Array(t.length);return ct(e,a,n)}function jt(t,r,n,e,a){if(f(n))return null;const o=new Float32Array(n.length);return x(y.fromTypedArray(o),y.fromTypedArray(n),e),ut(o,t,r,a,o),o}function Nt(t,r,n,e,a){if(f(n))return null;const o=new Float32Array(n.length);x(y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT),y.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),e);for(let i=3;i<o.length;i+=4)o[i]=n[i];return pt(o,t,r,a,o),o}function b(t,r,n){const e=new Float64Array(t.position.length),a=t.position,o=r.x,i=r.y,l=r.z||0,{horizontal:c,vertical:v}=E(n?n.unit:null,r.spatialReference);for(let s=0;s<a.length;s+=3)e[s+0]=(a[s+0]-o)/c,e[s+1]=(a[s+1]-i)/c,e[s+2]=(a[s+2]-l)/v;return{position:e,normal:t.normal,tangent:t.tangent}}function O(t,r,n){const e=r.spatialReference;S(r,n,k);const a=P(Pt,k),o=new Float64Array(t.position.length),i=zt(t.position,e,a,o),l=Y(U,a);return{position:i,normal:Lt(t.normal,t.position,o,e,l),tangent:It(t.tangent,t.position,o,e,l)}}function S(t,r,n){B(t.spatialReference,[t.x,t.y,t.z||0],n,_(t.spatialReference));const{horizontal:e,vertical:a}=E(r?r.unit:null,t.spatialReference);return st(n,n,[e,e,a]),n}function zt(t,r,n,e){const a=mt(t,r,e),o=h.fromTypedArray(a),i=new Float64Array(a.length),l=h.fromTypedArray(i);return d(l,o,n),i}function Lt(t,r,n,e,a){if(f(t))return null;const o=$t(t,r,n,e,new Float32Array(t.length)),i=y.fromTypedArray(o);return x(i,i,a),o}function It(t,r,n,e,a){if(f(t))return null;const o=At(t,r,n,e,new Float32Array(t.length)),i=y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT);return x(i,i,a),o}function E(t,r){if(f(t))return _t;const n=r.isGeographic?1:gt(r),e=r.isGeographic?1:ft(r),a=ht(1,t,"meters");return{horizontal:a*n,vertical:a*e}}const k=m(),Pt=m(),U=yt(),_t={horizontal:1,vertical:1};export{Mt as L,Rt as M,Ut as P,Ft as _,$ as a,F as b,Yt as c,St as k,Ot as l,qt as q,T as r,q as x};
