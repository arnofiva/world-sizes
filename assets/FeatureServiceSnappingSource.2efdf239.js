var U=Object.defineProperty,D=Object.defineProperties;var J=Object.getOwnPropertyDescriptors;var k=Object.getOwnPropertySymbols;var V=Object.prototype.hasOwnProperty,j=Object.prototype.propertyIsEnumerable;var b=(e,t,i)=>t in e?U(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,T=(e,t)=>{for(var i in t||(t={}))V.call(t,i)&&b(e,i,t[i]);if(k)for(var i of k(t))j.call(t,i)&&b(e,i,t[i]);return e},$=(e,t)=>D(e,J(t));import{k9 as L,p_ as A,p$ as W,b7 as q,dF as Q,d3 as z,h as O,J as c,bx as G,L as H,I as r,d as n,u as y,V as R,aW as B,q0 as K,y as X,a7 as Y,v as Z,gl as ee,bU as te,gH as ie,e2 as re,ey as ne,l1 as se,bb as ae,q1 as le,m8 as P,P as C,a5 as E,gt as oe,q2 as de}from"./vendor.d1b93dad.js";import{o as ue}from"./queryEngineUtils.26230fe4.js";import{b as pe}from"./TileTreeDebugger.f6c3d965.js";import"./PointSnappingHint.e9294712.js";function I(e,t){return A(t.extent,F),W(F,q(he,e.x,e.y,0))}const F=L(),he=Q();let l=class extends z(O){constructor(e){super(e),this.pointOfInterest=null}get tiles(){const e=this.tilesCoveringView,t=c(this.pointOfInterest)?this.pointOfInterest:this.view.center;return e.sort((i,a)=>I(t,i)-I(t,a)),e}_scaleEnabled(){return G(this.view.scale,this.layer.minScale||0,this.layer.maxScale||0)}get tilesCoveringView(){if(!this.view.ready||!this.view.featuresTilingScheme||!this.view.state||H(this.tileInfo))return[];if(!this._scaleEnabled)return[];const{spans:e,lodInfo:t}=this.view.featuresTilingScheme.getTileCoverage(this.view.state,0),{level:i}=t,a=[];for(const{row:s,colFrom:u,colTo:g}of e)for(let p=u;p<=g;p++){const v={id:null,level:i,row:s,col:t.normalizeCol(p)};this.tileInfo.updateTileInfo(v),a.push(v)}return a}get tileInfo(){var e,t;return(e=(t=this.view.featuresTilingScheme)==null?void 0:t.tileInfo)!=null?e:null}get tileSize(){return c(this.tileInfo)?this.tileInfo.size[0]:256}initialize(){this.handles.add(this.watch("view.state.viewpoint",()=>this.notifyChange("tilesCoveringView"),!0))}};r([n({readOnly:!0})],l.prototype,"tiles",null),r([n({readOnly:!0})],l.prototype,"_scaleEnabled",null),r([n({readOnly:!0})],l.prototype,"tilesCoveringView",null),r([n({readOnly:!0})],l.prototype,"tileInfo",null),r([n({readOnly:!0})],l.prototype,"tileSize",null),r([n({constructOnly:!0})],l.prototype,"view",void 0),r([n({constructOnly:!0})],l.prototype,"layer",void 0),r([n()],l.prototype,"pointOfInterest",void 0),l=r([y("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles2D")],l);let d=class extends R{constructor(e){super(e),this.pointOfInterest=null}get tiles(){const e=this.tilesCoveringView,t=this.effectivePointOfInterest;if(c(t)){const i=e.map(a=>I(t,a));for(let a=1;a<i.length;a++)if(i[a-1]>i[a])return e.sort((s,u)=>I(t,s)-I(t,u)),e.slice()}return e}get tilesCoveringView(){var e,t;return this._filterTiles((e=this.view.featureTiles)==null||(t=e.tiles)==null?void 0:t.toArray()).map(ce)}get tileInfo(){var e,t;return(e=(t=this.view.featureTiles)==null?void 0:t.tilingScheme.toTileInfo())!=null?e:null}get tileSize(){var e,t;return(e=(t=this.view.featureTiles)==null?void 0:t.tileSize)!=null?e:256}get effectivePointOfInterest(){var e;const t=this.pointOfInterest;return c(t)?t:(e=this.view.pointsOfInterest)==null?void 0:e.focus.location}initialize(){this.handles.add(B(this.view,"featureTiles",e=>{this.handles.remove(_),e&&this.handles.add(e.addClient(),_)}))}_filterTiles(e){return H(e)?[]:e.filter(t=>Math.abs(t.measures.screenRect[3]-t.measures.screenRect[1])>fe&&t.measures.visibility===K.VISIBLE_ON_SURFACE)}};function ce({lij:[e,t,i],extent:a}){return{id:`${e}/${t}/${i}`,level:e,row:t,col:i,extent:a}}r([n({readOnly:!0})],d.prototype,"tiles",null),r([n({readOnly:!0})],d.prototype,"tilesCoveringView",null),r([n({readOnly:!0})],d.prototype,"tileInfo",null),r([n({readOnly:!0})],d.prototype,"tileSize",null),r([n({constructOnly:!0})],d.prototype,"view",void 0),r([n()],d.prototype,"pointOfInterest",void 0),r([n()],d.prototype,"effectivePointOfInterest",null),d=r([y("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles3D")],d);const fe=50,_="feature-tiles";let m=class extends pe{constructor(e){super(e),this.handles=new X}initialize(){const e=setInterval(()=>this._fetchDebugInfo(),2e3);this.handles.add(Y(()=>clearInterval(e)))}destroy(){this.handles.destroy()}getTiles(){if(!this.debugInfo)return[];const e=new Map,t=new Map;this.debugInfo.storedTiles.forEach(s=>{e.set(s.data.id,s.featureCount)}),this.debugInfo.pendingTiles.forEach(s=>{e.set(s.data.id,s.featureCount),t.set(s.data.id,s.state)});const i=s=>{var u;const g=t.get(s),p=(u=e.get(s))!=null?u:"?";return g?`${g}:${p}
${s}`:`store:${p}
${s}`},a=new Map;return this.debugInfo.storedTiles.forEach(s=>{a.set(s.data.id,s.data)}),this.debugInfo.pendingTiles.forEach(s=>{a.set(s.data.id,s.data)}),Array.from(a.values()).map(s=>({lij:[s.level,s.row,s.col],geometry:Z.fromExtent(ee(s.extent,this.view.spatialReference)),label:i(s.id)}))}_fetchDebugInfo(){this.handle.getDebugInfo(null).then(e=>{this.debugInfo=e,this.update()})}};r([n({constructOnly:!0})],m.prototype,"handle",void 0),m=r([y("esri.views.interactive.snapping.featureSources.WorkerTileTreeDebugger")],m);let h=class extends R{constructor(e){super(e),this.availability=0,this.workerHandleUpdating=!0,this.editId=0}get updating(){return this.updatingHandles.updating||this.workerHandleUpdating}destroy(){this.workerHandle.destroy()}initialize(){this.workerHandle=new ge(this.schedule),this.handles.add([this.workerHandle.on("notify-updating",({updating:e})=>this.workerHandleUpdating=e),this.workerHandle.on("notify-availability",({availability:e})=>this._set("availability",e))])}async setup(e,t){const i=this._serviceInfoFromLayer(e.layer);if(H(i))return;const a={configuration:this._convertConfiguration(e.configuration),serviceInfo:i,spatialReference:e.spatialReference.toJSON()};await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("setup",a,t)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t))}async configure(e,t){const i=this._convertConfiguration(e);await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("configure",i,t)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t))}async refresh(e){await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("refresh",{},e)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},e))}async fetchCandidates(e,t){const i={distance:e.distance,point:e.coordinateHelper.vectorToPoint(e.point).toJSON(),types:e.types,filter:c(e.filter)?e.filter.createQuery().toJSON():null};return this.workerHandle.invoke(i,t)}async updateTiles(e,t){const i={tiles:e.tiles,tileInfo:c(e.tileInfo)?e.tileInfo.toJSON():null,tileSize:e.tileSize};await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("updateTiles",i,t)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t))}async applyEdits(e,t){var i,a,s,u,g,p;const v=this.editId++,x={id:v};await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("beginApplyEdits",x,t)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t));const S=await this.updatingHandles.addPromise(te(e.result,t)),N={id:v,edits:{addedFeatures:(i=(a=S.addedFeatures)==null?void 0:a.map(({objectId:w})=>w))!=null?i:[],deletedFeatures:(s=(u=S.deletedFeatures)==null?void 0:u.map(({objectId:w,globalId:M})=>({objectId:w,globalId:M})))!=null?s:[],updatedFeatures:(g=(p=S.updatedFeatures)==null?void 0:p.map(({objectId:w})=>w))!=null?g:[]}};await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("endApplyEdits",N,t)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t))}getDebugInfo(e){return this.workerHandle.invokeMethod("getDebugInfo",{},e)}_convertConfiguration(e){return{filter:c(e.filter)?e.filter.toJSON():null,customParameters:e.customParameters}}_serviceInfoFromLayer(e){var t;return e.geometryType==="multipatch"||e.geometryType==="mesh"?null:{url:e.parsedUrl.path,fields:e.fields.map(i=>i.toJSON()),geometryType:ie.toJSON(e.geometryType),capabilities:e.capabilities,objectIdField:e.objectIdField,globalIdField:e.globalIdField,spatialReference:e.spatialReference.toJSON(),timeInfo:(t=e.timeInfo)==null?void 0:t.toJSON()}}};r([n({constructOnly:!0})],h.prototype,"schedule",void 0),r([n({readOnly:!0})],h.prototype,"updating",null),r([n({readOnly:!0})],h.prototype,"availability",void 0),r([n()],h.prototype,"workerHandleUpdating",void 0),h=r([y("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")],h);class ge extends re{constructor(t){super("FeatureServiceSnappingSourceWorker","fetchCandidates",t,{strategy:"dedicated"})}getTransferList(){return[]}}let f=class extends O{constructor(e){super(e),this.pointOfInterest=null}get tiles(){return[{id:"0/0/0",level:0,row:0,col:0,extent:ne(-1e8,-1e8,1e8,1e8)}]}get tileInfo(){return new se({origin:new ae({x:-1e8,y:1e8,spatialReference:this.layer.spatialReference}),size:[512,512],lods:[new le({level:0,scale:1,resolution:390625})],spatialReference:this.layer.spatialReference})}get tileSize(){return this.tileInfo.size[0]}};r([n({readOnly:!0})],f.prototype,"tiles",null),r([n({readOnly:!0})],f.prototype,"tileInfo",null),r([n({readOnly:!0})],f.prototype,"tileSize",null),r([n({constructOnly:!0})],f.prototype,"layer",void 0),r([n()],f.prototype,"pointOfInterest",void 0),f=r([y("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTilesSimple")],f);let o=class extends z(O){constructor(e){super(e)}get updateTilesParameters(){return{tiles:this.tilesOfInterest.tiles,tileInfo:this.tilesOfInterest.tileInfo,tileSize:this.tilesOfInterest.tileSize}}get updating(){return this.workerHandle.updating||this.updatingHandles.updating}get configuration(){return{filter:this.layer.createQuery(),customParameters:this.layer.customParameters}}get availability(){return this.workerHandle.availability}get layer(){return this.layerSource.layer}initialize(){const e=this.view;if(c(e))switch(e.type){case"2d":this.tilesOfInterest=new l({view:e,layer:this.layer}),this.workerHandle=new h;break;case"3d":{const t=e.resourceController;this.tilesOfInterest=new d({view:e}),this.workerHandle=new h({schedule:i=>t.schedule(i)});break}}else this.tilesOfInterest=new f({layer:this.layer}),this.workerHandle=new h;this.handles.add([P(this.workerHandle)]),this.workerHandle.setup({layer:this.layer,spatialReference:this.spatialReference,configuration:this.configuration},null),this.updatingHandles.add(()=>this.updateTilesParameters,()=>this.workerHandle.updateTiles(this.updateTilesParameters,null),C),this.handles.add([E(()=>this.configuration,t=>this.workerHandle.configure(t,null),oe)]),c(e)&&this.handles.add(E(()=>de.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES,t=>{t&&!this.debug?(this.debug=new m({view:e,handle:this.workerHandle}),this.handles.add(P(this.debug),"debug")):!t&&this.debug&&this.handles.remove("debug")},C)),this.handles.add(this.layerSource.layer.on("apply-edits",t=>{this.workerHandle.applyEdits(t,null)}))}refresh(){this.workerHandle.refresh(null)}async fetchCandidates(e,t){return this.tilesOfInterest.pointOfInterest=e.coordinateHelper.vectorToPoint(e.point),(await this.workerHandle.fetchCandidates($(T({},e),{filter:null}),t)).candidates.map(i=>ue(i,e.coordinateHelper))}getDebugInfo(e){return this.workerHandle.getDebugInfo(e)}};r([n({constructOnly:!0})],o.prototype,"spatialReference",void 0),r([n({constructOnly:!0})],o.prototype,"layerSource",void 0),r([n({constructOnly:!0})],o.prototype,"view",void 0),r([n()],o.prototype,"tilesOfInterest",void 0),r([n({readOnly:!0})],o.prototype,"updateTilesParameters",null),r([n({readOnly:!0})],o.prototype,"updating",null),r([n({readOnly:!0})],o.prototype,"configuration",null),r([n({readOnly:!0})],o.prototype,"availability",null),o=r([y("esri.views.interactive.snapping.featureSources.FeatureServiceSnappingSource")],o);export{o as FeatureServiceSnappingSource};
