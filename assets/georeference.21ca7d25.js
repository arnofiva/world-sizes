import{I as u,d as g,u as G,eF as O,aH as b,hG as q,ka as Y,my as H,kH as S,dE as j,di as m,dH as E,nd as f,dt as z,dh as L,ek as U,ne as A,bv as C,nf as D,mt as J,ng as V,bb as W,J as v,m2 as K,nh as Q,k3 as T,jT as X,ni as Z,nj as k,L as h,nk as d,kA as y,nl as tt,nm as nt,nn as rt,az as et,iU as at,dG as ot,no as it,np as lt,nq as st,nr as ct,ns as pt,nt as ut}from"./vendor.d1b93dad.js";import{a as N,l as gt,x as ht}from"./axisAngleDegrees.f9e2944e.js";var w;let p=w=class extends O{constructor(t){super(t),this.origin=b(),this.translation=b(),this.rotation=N(),this.scale=q(1,1,1),this.geographic=!0}get localMatrix(){const t=m();return Y(t,this.scale),H(t,t,ht(this.rotation),gt(this.rotation)),S(t,t,this.translation),t}get localMatrixInverse(){return j(m(),this.localMatrix)}applyLocal(t,r){return E(r,t,this.localMatrix)}applyLocalInverse(t,r){return E(r,t,this.localMatrixInverse)}project(t,r){const n=new Float64Array(t.length),e=f.fromTypedArray(n),a=f.fromTypedArray(t);if(this.geographic){const l=z(r),c=m();return L(r,this.origin,c,l),U(c,c,this.localMatrix),A(e,a,c),C(n,l,0,n,r,0,n.length/3),n}const{localMatrix:o,origin:i}=this;D(o,J)?V(e,a):A(e,a,o);for(let l=0;l<n.length;l+=3)n[l+0]+=i[0],n[l+1]+=i[1],n[l+2]+=i[2];return n}getOriginPoint(t){const[r,n,e]=this.origin;return new W({x:r,y:n,z:e,spatialReference:t})}equals(t){return v(t)&&this.geographic===t.geographic&&K(this.origin,t.origin)&&Q(this.localMatrix,t.localMatrix)}clone(){const t={origin:T(this.origin),translation:T(this.translation),rotation:N(this.rotation),scale:T(this.scale),geographic:this.geographic};return new w(t)}};u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"origin",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"translation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"rotation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"scale",void 0),u([g({type:Boolean,nonNullable:!0,json:{write:!0}})],p.prototype,"geographic",void 0),u([g()],p.prototype,"localMatrix",null),u([g()],p.prototype,"localMatrixInverse",null),p=w=u([G("esri.geometry.support.MeshTransform")],p);const ft=p;function x(t,r){var n;return t.isGeographic||t.isWebMercator&&((n=r==null?void 0:r.geographic)==null||n)}function B(t,r,n){return x(r.spatialReference,n)?dt(t,r,n):At(t,r,n)}function yt(t,r,n){const{position:e,normal:a,tangent:o}=t;if(h(r))return{position:e,normal:a,tangent:o};const i=r.localMatrix;return B({position:ct(e,new Float64Array(e.length),i),normal:v(a)?pt(a,new Float32Array(a.length),i):null,tangent:v(o)?ut(o,new Float32Array(o.length),i):null},r.getOriginPoint(n),{geographic:r.geographic})}function Nt(t,r,n){if(n!=null&&n.useTransform){var e;const{position:a,normal:o,tangent:i}=t;return{vertexAttributes:{position:a,normal:o,tangent:i},transform:new ft({origin:[r.x,r.y,(e=r.z)!=null?e:0],geographic:x(r.spatialReference,n)})}}return{vertexAttributes:B(t,r,n),transform:null}}function mt(t,r,n){return x(r.spatialReference,n)?I(t,r,n):F(t,r,n)}function jt(t,r,n,e){if(h(r))return mt(t,n,e);const a=yt(t,r,n.spatialReference);return n.equals(r.getOriginPoint(n.spatialReference))?F(a,n,e):x(n.spatialReference,e)?I(a,n,e):F(a,n,e)}function At(t,r,n){const e=new Float64Array(t.position.length),a=t.position,o=r.x,i=r.y,l=r.z||0,{horizontal:c,vertical:$}=R(n?n.unit:null,r.spatialReference);for(let s=0;s<a.length;s+=3)e[s+0]=a[s+0]*c+o,e[s+1]=a[s+1]*c+i,e[s+2]=a[s+2]*$+l;return{position:e,normal:t.normal,tangent:t.tangent}}function dt(t,r,n){const e=r.spatialReference,a=P(r,n,M),o=new Float64Array(t.position.length),i=xt(t.position,a,e,o),l=k(_,a);return{position:i,normal:$t(i,o,t.normal,l,e),tangent:Tt(i,o,t.tangent,l,e)}}function xt(t,r,n,e){A(f.fromTypedArray(e),f.fromTypedArray(t),r);const a=new Float64Array(t.length);return Z(e,a,n)}function $t(t,r,n,e,a){if(h(n))return null;const o=new Float32Array(n.length);return d(y.fromTypedArray(o),y.fromTypedArray(n),e),tt(o,t,r,a,o),o}function Tt(t,r,n,e,a){if(h(n))return null;const o=new Float32Array(n.length);d(y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT),y.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),e);for(let i=3;i<o.length;i+=4)o[i]=n[i];return nt(o,t,r,a,o),o}function F(t,r,n){const e=new Float64Array(t.position.length),a=t.position,o=r.x,i=r.y,l=r.z||0,{horizontal:c,vertical:$}=R(n?n.unit:null,r.spatialReference);for(let s=0;s<a.length;s+=3)e[s+0]=(a[s+0]-o)/c,e[s+1]=(a[s+1]-i)/c,e[s+2]=(a[s+2]-l)/$;return{position:e,normal:t.normal,tangent:t.tangent}}function I(t,r,n){const e=r.spatialReference;P(r,n,M);const a=j(Mt,M),o=new Float64Array(t.position.length),i=vt(t.position,e,a,o),l=k(_,a);return{position:i,normal:wt(t.normal,t.position,o,e,l),tangent:Ft(t.tangent,t.position,o,e,l)}}function P(t,r,n){L(t.spatialReference,[t.x,t.y,t.z||0],n,z(t.spatialReference));const{horizontal:e,vertical:a}=R(r?r.unit:null,t.spatialReference);return X(n,n,[e,e,a]),n}function vt(t,r,n,e){const a=it(t,r,e),o=f.fromTypedArray(a),i=new Float64Array(a.length),l=f.fromTypedArray(i);return A(l,o,n),i}function wt(t,r,n,e,a){if(h(t))return null;const o=lt(t,r,n,e,new Float32Array(t.length)),i=y.fromTypedArray(o);return d(i,i,a),o}function Ft(t,r,n,e,a){if(h(t))return null;const o=st(t,r,n,e,new Float32Array(t.length)),i=y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT);return d(i,i,a),o}function R(t,r){if(h(t))return Rt;const n=r.isGeographic?1:rt(r),e=r.isGeographic?1:et(r),a=at(1,t,"meters");return{horizontal:a*n,vertical:a*e}}const M=m(),Mt=m(),_=ot(),Rt={horizontal:1,vertical:1};export{ft as L,mt as M,jt as P,yt as _,Nt as k,x as r,B as x};
