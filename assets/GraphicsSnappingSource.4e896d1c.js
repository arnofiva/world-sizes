import{bs as F,jw as N,n4 as z,q6 as k,ik as G,ij as H,fk as W,fi as E,ii as L,fF as T,q7 as q,q8 as B,q9 as S,d3 as D,h as Q,hs as U,J as y,qa as X,L as J,c0 as Z,bQ as V,v as Y,bj as K,Y as ee,ao as te,nD as se,gH as ie,I as x,d as g,u as re,e3 as ae}from"./vendor.d1b93dad.js";import{m as ne}from"./FeatureStore.6d3fd27f.js";import{V as oe}from"./QueryEngine.b25a2b06.js";import{o as ce}from"./queryEngineUtils.26230fe4.js";import"./PooledRBush.74db5953.js";import"./quickselect.02d2bace.js";import"./optimizedFeatureQueryEngineAdapter.264950bf.js";import"./QueryEngineCapabilities.650d7541.js";import"./PointSnappingHint.e9294712.js";function de(e){if(!e)return null;let t=null;const i=e.spatialReference,s=N(i);if(!s)return"toJSON"in e?e.toJSON():e;const r=z(i)?102100:4326,a=k[r].maxX,n=k[r].minX,p=k[r].plus180Line,l=k[r].minus180Line;let m;const o="toJSON"in e?e.toJSON():e;if(G(o))m=P(o,a,n);else if(H(o))o.points=o.points.map(c=>P(c,a,n)),m=o;else if(W(o))m=le(o,s);else if(E(o)||L(o)){const c=he;T(c,o);const d={xmin:c[0],ymin:c[1],xmax:c[2],ymax:c[3]},u=S(d.xmin,n)*(2*a),h=u===0?o:me(o,u);d.xmin+=u,d.xmax+=u,q(d,p)&&d.xmax!==a||q(d,l)&&d.xmin!==n?t=h:m=h}else m=o;return t!==null?new pe().cut(t,a):m}function me(e,t){const i=B(e);for(const s of i)for(const r of s)r[0]+=t;return e}function le(e,t){if(!t)return e;const i=ue(e,t).map(s=>s.extent);return i.length<2?i[0]||e:i.length>2?(e.xmin=t.valid[0],e.xmax=t.valid[1],e):{rings:i.map(s=>[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]])}}function P(e,t,i){if(Array.isArray(e)){const s=e[0];if(s>t){const r=S(s,t);e[0]=s+r*(-2*t)}else if(s<i){const r=S(s,i);e[0]=s+r*(-2*i)}}else{const s=e.x;if(s>t){const r=S(s,t);e.x+=r*(-2*t)}else if(s<i){const r=S(s,i);e.x+=r*(-2*i)}}return e}function ue(e,t){const i=[],{ymin:s,ymax:r}=e,a=e.xmax-e.xmin,n=e.xmin,p=e.xmax;let l;const[m,o]=t.valid;l=j(e.xmin,t);const c=l.x,d=l.frameId;l=j(e.xmax,t);const u=l.x,h=l.frameId,C=c===u&&a>0;if(a>2*o){const b={xmin:n<p?c:u,ymin:s,xmax:o,ymax:r},M={xmin:m,ymin:s,xmax:n<p?u:c,ymax:r},R={xmin:0,ymin:s,xmax:o,ymax:r},A={xmin:m,ymin:s,xmax:0,ymax:r},_=[],v=[];I(b,R)&&_.push(d),I(b,A)&&v.push(d),I(M,R)&&_.push(h),I(M,A)&&v.push(h);for(let w=d+1;w<h;w++)_.push(w),v.push(w);i.push({extent:b,frameIds:[d]},{extent:M,frameIds:[h]},{extent:R,frameIds:_},{extent:A,frameIds:v})}else c>u||C?i.push({extent:{xmin:c,ymin:s,xmax:o,ymax:r},frameIds:[d]},{extent:{xmin:m,ymin:s,xmax:u,ymax:r},frameIds:[h]}):i.push({extent:{xmin:c,ymin:s,xmax:u,ymax:r},frameIds:[d]});return i}function j(e,t){const[i,s]=t.valid,r=2*s;let a,n=0;return e>s?(a=Math.ceil(Math.abs(e-s)/r),e-=a*r,n=a):e<i&&(a=Math.ceil(Math.abs(e-i)/r),e+=a*r,n=-a),{x:e,frameId:n}}function I(e,t){const{xmin:i,ymin:s,xmax:r,ymax:a}=t;return O(e,i,s)&&O(e,i,a)&&O(e,r,a)&&O(e,r,s)}function O(e,t,i){return t>=e.xmin&&t<=e.xmax&&i>=e.ymin&&i<=e.ymax}class pe{cut(t,i){let s;if(t.rings)this.closed=!0,s=t.rings,this.minPts=4;else{if(!t.paths)return null;this.closed=!1,s=t.paths,this.minPts=2}const r=s.length,a=-2*i;for(let n=0;n<r;n++){const p=s[n];if(p&&p.length>=this.minPts){const l=[];for(const m of p)l.push([m[0]+a,m[1]]);s.push(l)}}return this.closed?t.rings=s:t.paths=s,t}}const he=F();let f=class extends D(Q){constructor(e){super(e),this.availability=1,this.sources={multipoint:null,point:null,polygon:null,polyline:null},this.loadedWkids=new Set,this.loadedWkts=new Set,this.pendingAdds=[]}get updating(){return this.updatingHandles.updating}get layer(){return this.layerSource.layer}destroy(){const e=this.pendingAdds;this.pendingAdds.length=0;for(const t of e)t.task.abort();this._mapSources(t=>this._destroySource(t))}initialize(){this.handles.add([this.layer.on("graphic-update",e=>this._onGraphicUpdate(e)),this.updatingHandles.addOnCollectionChange(()=>this.layer.graphics,e=>this._onGraphicsChanged(e))]),this._addMany(this.layer.graphics.toArray())}async fetchCandidates(e,t){const i=await U(this._mapSources(r=>r.queryEngine.executeQueryForSnapping({point:e.coordinateHelper.vectorToPoint(e.point).toJSON(),distance:e.distance,types:e.types,query:y(e.filter)?e.filter.createQuery().toJSON():{where:"1=1"}},t).then(({candidates:a})=>a))),s=i.flat().map(r=>ce(r,e.coordinateHelper));return X(e.point,s),s}refresh(){}_onGraphicUpdate(e){switch(e.property){case"geometry":case"visible":this._remove(e.graphic),this._addMany([e.graphic])}}_onGraphicsChanged(e){for(const t of e.removed)this._remove(t);this._addMany(e.added)}_addMany(e){const t=[],i=new Map;for(const s of e)J(s.geometry)||(this._needsInitializeProjection(s.geometry.spatialReference)?(t.push(s.geometry.spatialReference),i.set(s.uid,s)):this._add(s));this._createPendingAdd(t,i)}_createPendingAdd(e,t){if(!e.length)return;const i=Z(async a=>{await V(e.map(n=>({source:n,dest:this.spatialReference})),{signal:a}),this._markLoadedSpatialReferences(e);for(const[,n]of t)this._add(n)});this.updatingHandles.addPromise(i.promise);const s={task:i,graphics:t},r=()=>ae(this.pendingAdds,s);i.promise.then(r,r),this.pendingAdds.push(s)}_markLoadedSpatialReferences(e){for(const t of e)t.wkid!=null&&this.loadedWkids.add(t.wkid),t.wkt!=null&&this.loadedWkts.add(t.wkt)}_add(e){if(J(e.geometry)||!e.visible)return;let t=e.geometry;if(t.type==="mesh")return;t.type==="extent"&&(t=Y.fromExtent(t));const i=this._ensureSource(t.type);if(J(i))return;const s=this._createOptimizedFeature(e.uid,t);y(s)&&i.featureStore.add(s)}_needsInitializeProjection(e){return(e.wkid==null||!this.loadedWkids.has(e.wkid))&&(e.wkt==null||!this.loadedWkts.has(e.wkt))&&!K(e,this.spatialReference)}_createOptimizedFeature(e,t){const i=ee(de(t),this.spatialReference);return i?new te(se(i,!1,!1),{[$]:e},null,e):null}_ensureSource(e){const t=this.sources[e];if(y(t))return t;const i=this._createSource(e);return this.sources[e]=i,i}_createSource(e){const t=ie.toJSON(e),i=new ne({geometryType:t,hasZ:!1,hasM:!1});return{featureStore:i,queryEngine:new oe({featureStore:i,fields:[{name:$,type:"esriFieldTypeOID",alias:$}],geometryType:t,hasM:!1,hasZ:!1,objectIdField:$,spatialReference:this.spatialReference,scheduler:y(this.view)&&this.view.type==="3d"?this.view.resourceController.scheduler:null}),type:e}}_remove(e){this._mapSources(t=>this._removeFromSource(t,e));for(const t of this.pendingAdds)t.graphics.delete(e.uid),t.graphics.size===0&&t.task.abort()}_removeFromSource(e,t){const i=t.uid;e.featureStore.has(i)&&e.featureStore.removeById(t.uid)}_destroySource(e){e.queryEngine.destroy(),this.sources[e.type]=null}_mapSources(e){const{point:t,polygon:i,polyline:s,multipoint:r}=this.sources,a=[];return y(t)&&a.push(e(t)),y(i)&&a.push(e(i)),y(s)&&a.push(e(s)),y(r)&&a.push(e(r)),a}};x([g({constructOnly:!0})],f.prototype,"spatialReference",void 0),x([g({constructOnly:!0})],f.prototype,"layerSource",void 0),x([g({constructOnly:!0})],f.prototype,"view",void 0),x([g({readOnly:!0})],f.prototype,"updating",null),x([g({readOnly:!0})],f.prototype,"availability",void 0),f=x([re("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")],f);const $="OBJECTID";export{f as GraphicsSnappingSource};
