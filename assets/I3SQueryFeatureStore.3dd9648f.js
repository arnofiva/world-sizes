import{aa as de,a as c,d as l,cT as pe,n as B,am as K,h as q,aN as ye,t as v,r as b,d1 as Z,ee as he,c1 as U,d7 as z,ef as fe,bv as H,eg as ge,eh as me,bm as Ee,bf as Se,bl as be,ei as Ie,ej as we,dJ as N,aQ as D,aP as M,aO as L,u as Re,F as Oe,ao as xe,L as Y,ek as Fe,a1 as P,b7 as $e,_ as _e,bM as Qe,ah as ve,dk as je}from"./vendor.f59113c8.js";import{WhereClause as Ce}from"./WhereClause.d621a470.js";import{t as Te,e as Ne,y as X}from"./I3SUtil.329b1a5b.js";import{V as De}from"./QueryEngine.7ca31221.js";import{e as Me}from"./centroid.7fe573f3.js";import{L as T}from"./I3SMeshView3D.64856d5d.js";const C=de.getLogger("esri.views.3d.layers.i3s.I3SMeshViewFilter");let f,h=class extends q{constructor(e){super(e),this._projectionEngineLoaded=!1}initialize(){ye(this,"filter.geometry").then(()=>this.loadAsyncModule(Ge().then(e=>{this.destroyed||(this._geometryEngine=e,this.applyFilters())})))}get sortedObjectIds(){if(v(this.filter.objectIds))return null;const e=new Float64Array(this.filter.objectIds);return e.sort(),e}get parsedWhereClause(){const e=b(this.filter)?this.filter.where:null;if(v(e)||!e)return null;try{return Ce.create(e,this.layerFieldsIndex)}catch(t){C.error(`Failed to parse filter where clause: ${t}`)}return null}addFilters(e,t,r,s){const i=this.sortedObjectIds;b(i)&&e.push(a=>Te(i,!0,a)),this.addSqlFilter(e,this.parsedWhereClause);const n=this.parsedGeometry;if(b(n)){const a=this.spatialRelationship;e.push((o,d)=>ke(o,d,s,t,r,n,a))}}isMBSGeoemtryVisible(e,t,r){const s=this.parsedGeometry;if(b(s)){const i=this.spatialRelationship,n=s[0].spatialReference||t;return Z(e,r,G,n)?Ve(G,s,n,i):(C.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter for MBS"),!0)}return!0}get parsedGeometry(){if(v(this.filter)||!this._geometryEngine)return null;const{geometry:e}=this.filter;if(v(e))return null;const{distance:t,units:r}=this.filter,s=this.spatialRelationship,i=e.type==="mesh"?e.extent:e;if(v(t)||t===0)return A(i,s);const n=r||he(i.spatialReference);if(i.spatialReference.isWGS84)return A(this._geometryEngine.geodesicBuffer(i,t,n),s);const a=U(i,z.WGS84);if(b(a))return A(U(this._geometryEngine.geodesicBuffer(a,t,n),i.spatialReference),s);if(!this._projectionEngineLoaded&&(this.loadAsyncModule(fe().then(()=>this._projectionEngineLoaded=!0)),!this._projectionEngineLoaded))return null;let o=null;try{o=H(i,z.WGS84)}catch{}if(o)try{o=H(this._geometryEngine.geodesicBuffer(o,t,n),i.spatialReference)}catch{o=null}return o||C.error(`Filter by geodesic buffer (distance) unsupported, failed to project input geometry (${i.spatialReference.wkid}) to WGS84.`),A(o,s)}get spatialRelationship(){return b(this.filter)?this.filter.spatialRelationship:"intersects"}static checkSupport(e){return e.timeExtent?(C.warn("Filters with a timeExtent are not supported for mesh scene layers"),!1):!!Je(e.spatialRelationship)||(C.warn(`Filters with spatialRelationship other than ${te.join(", ")} are not supported for mesh scene layers`),!1)}};function Ae(){return!!f}async function Ge(){return Ae()||(f=await import("./geometryEngine.53974a6d.js")),f}c([l({type:pe})],h.prototype,"filter",void 0),c([l()],h.prototype,"layerFieldsIndex",void 0),c([l()],h.prototype,"loadAsyncModule",void 0),c([l()],h.prototype,"applyFilters",void 0),c([l()],h.prototype,"addSqlFilter",void 0),c([l({readOnly:!0})],h.prototype,"sortedObjectIds",null),c([l({readOnly:!0})],h.prototype,"parsedWhereClause",null),c([l({readOnly:!0})],h.prototype,"parsedGeometry",null),c([l({readOnly:!0})],h.prototype,"spatialRelationship",null),c([l()],h.prototype,"_projectionEngineLoaded",void 0),c([l()],h.prototype,"_geometryEngine",void 0),h=c([B("esri.views.3d.layers.i3s.I3SMeshViewFilter")],h);const te=(e=>e)(["contains","intersects","disjoint"]);function Je(e){return e!=null&&te.indexOf(e)>=0}var u;function A(e,t){if(v(e))return null;if(t==="disjoint"&&e.type==="polygon"){const r=new Array(e.rings.length);for(let n=0;n<e.rings.length;++n){const a=ge(1/0,1/0,-1/0,-1/0);me(a,e.rings[n]),r[n]={type:"polygon",rings:[e.rings[n]],spatialReference:e.spatialReference,aabr:a}}r.sort((n,a)=>n.aabr[0]-a.aabr[0]);const s=new Set,i=new Ee;for(let n=0;n<r.length;++n){const a=r[n];for(let o=n+1;o<r.length;++o){const d=r[o];if(d.aabr[0]>=a.aabr[2])break;s.add(d)}s.forEach(o=>{if(a!==o){if(o.aabr[2]<=a.aabr[0])s.delete(o);else if(f.intersects(a,o)){a.rings=a.rings.concat(o.rings),Se(a.aabr,o.aabr,a.aabr),delete a._geVersion,s.delete(o);const d=be(r,o,r.length,i);r.splice(d,1)}}}),s.add(a)}for(const n of r)delete n.aabr;return r}return[e]}function Ve(e,t,r,s){const i=re(e,r);return t.every(n=>ne(n,i,s)!==u.DISCARD)}function ke(e,t,r,s,i,n,a){const o=n[0].spatialReference||s.spatialReference;if(!Z(t.node.mbs,i,G,o))return void C.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter");const d=re(G,o),p=Le(a,s,o,r,t.objectHandle);for(const y of n){if(e.length===0)return;switch(ne(y,d,a)){case u.DISCARD:return void(e.length=0);case u.KEEP:continue}Ne(e,t.featureIds,I=>We(y,I,p))}}(function(e){e[e.KEEP=0]="KEEP",e[e.DISCARD=1]="DISCARD",e[e.TEST=2]="TEST"})(u||(u={}));const G=[0,0,0,0];function Le(e,t,r,s,i){const n=t.renderSpatialReference,a=new Map,o={rings:[[[0,0,0],[0,0,0],[0,0,0],[0,0,0]]],hasZ:!1,hasM:!1,type:"polygon",spatialReference:r};o.rings[0][3]=o.rings[0][0];const d={indices:null,data:null,stride:0,startIndex:0,endIndex:0};let p,y;switch(e){case"intersects":p=(I,$)=>f.intersects(I,$)?u.KEEP:u.TEST,y=W;break;case"contains":p=(I,$)=>f.contains(I,$)?u.TEST:u.DISCARD,y=W;break;default:p=(I,$)=>f.disjoint(I,$)?u.TEST:u.DISCARD,y=se}return{collection:s,object:i,type:e,maskSR:r,renderSR:n,aabbCache:a,triangle:o,positions:d,triangleTest:p,geometryTest:y}}function re(e,t){const r={x:e[0],y:e[1],hasZ:!1,hasM:!1,type:"point",spatialReference:t},s=!t.isWGS84&&!t.isWebMercator,i=Number.isNaN(e[3])?0:Ie(e[3],0,2*we.radius),n=s?f.buffer(r,i,1):f.geodesicBuffer(r,i,1);return n.type="polygon",n}function ne(e,t,r){switch(r){case"intersects":case"contains":return W(e,t);case"disjoint":return se(e,t)}}function W(e,t){return f.intersects(e,t)?f.contains(e,t)?u.KEEP:u.TEST:u.DISCARD}function se(e,t){return f.intersects(e,t)?f.contains(e,t)?u.DISCARD:u.TEST:u.KEEP}const Pe=2**-32;function We(e,t,r){const{collection:s,object:i,renderSR:n,maskSR:a,geometryTest:o,aabbCache:d}=r;let p=d.get(t);if(!p){const _=s.getObjectTransform(i);s.getComponentAabb(i,t,x);const E=[[x[0],x[1],0],[x[0],x[4],0],[x[3],x[4],0],[x[3],x[1],0]];for(let g=0;g<4;++g)N(E[g],E[g],_.rotationScale),D(E[g],E[g],_.position),M(E[g],n,E[g],a);p={rings:[E],hasZ:!1,hasM:!1,type:"polygon",spatialReference:a},p.rings[0][4]=p.rings[0][0],d.set(t,p)}switch(o(e,p)){case u.DISCARD:return!1;case u.KEEP:return!0}const{triangle:y,triangleTest:I,positions:$}=r,m=y.rings[0][0],w=y.rings[0][1],R=y.rings[0][2],j=s.getObjectTransform(i);s.getComponentPositions(i,t,$);const{indices:J,data:O,stride:V,startIndex:ie,endIndex:ae}=$;for(let _=ie;_<ae;_+=3){const E=V*J[_+0],g=V*J[_+1],k=V*J[_+2];L(m,O[E+0],O[E+1],O[E+2]),L(w,O[g+0],O[g+1],O[g+2]),L(R,O[k+0],O[k+1],O[k+2]),N(m,m,j.rotationScale),N(w,w,j.rotationScale),N(R,R,j.rotationScale),D(m,m,j.position),D(w,w,j.position),D(R,R,j.position),M(m,n,m,a),M(w,n,w,a),M(R,n,R,a);const oe=w[0]-m[0],ce=w[1]-m[1],le=R[0]-m[0],ue=R[1]-m[1];if(!(Math.abs(oe*ue-ce*le)<Pe))switch(delete y._geVersion,I(e,y)){case u.DISCARD:return!1;case u.KEEP:return!0}}return r.type!=="intersects"}const x=K(),Be=De;let F=class extends q{constructor(e){super(e),this._dataQueryEngineInstance=null,this._handles=new Re}get defaultQueryJSON(){return new Oe({outSpatialReference:this.spatialReference}).toJSON()}get dataQueryEngine(){return this._ensureDataQueryEngine()}initialize(){this._handles.add(this.layerView.on("visible-geometry-changed",()=>this.spatialIndex.events.emit("changed")))}destroy(){this._dataQueryEngineInstance&&(this._dataQueryEngineInstance.destroy(),this._dataQueryEngineInstance=null),this._handles&&(this._handles.destroy(),this._handles=null),this._set("layerView",null)}async executeQueryForCount(e,t){return this.dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(e),t)}async executeQueryForExtent(e,t){const{count:r,extent:s}=await this.dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(e),t);return{count:r,extent:xe.fromJSON(s)}}async executeQueryForIds(e,t){return this.dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(e),t)}async executeQuery(e,t){const r=this._ensureQueryJSON(e);if(r.returnGeometry)throw new Y("feature-store:unsupported-query","returnGeometry is not yet supported for mesh scene layer queries");if(r.returnCentroid)throw new Y("feature-store:unsupported-query","returnCentroid is not yet supported for mesh scene layer queries");const s=await this.dataQueryEngine.executeQuery(r,t),i=Fe.fromJSON(s);return i.features.forEach(n=>{n.geometry=null}),i}_ensureQueryJSON(e){if(v(e))return this.defaultQueryJSON;const t=e.toJSON();return t.outSpatialReference||(e.outSpatialReference=this.spatialReference),t}_ensureDataQueryEngine(){if(this._dataQueryEngineInstance)return this._dataQueryEngineInstance;const e=this.layer.objectIdField||"OBJECTID",t="esriGeometryPolygon",r=this.layer.fields.map(o=>o.toJSON()),s=this.layerView.view.resourceController.scheduler,i=this.spatialReference.toJSON(),n=this.priority,a=this.spatialIndex;return this._dataQueryEngineInstance=new Be({hasZ:!0,hasM:!1,geometryType:t,fields:r,timeInfo:null,spatialReference:i,objectIdField:e,featureStore:a,scheduler:s,priority:n}),this._dataQueryEngineInstance}};c([l({constructOnly:!0})],F.prototype,"layerView",void 0),c([l({constructOnly:!0})],F.prototype,"priority",void 0),c([l({constructOnly:!0})],F.prototype,"spatialIndex",void 0),c([l({readOnly:!0,aliasOf:"layerView.view.spatialReference"})],F.prototype,"spatialReference",void 0),c([l({readOnly:!0,aliasOf:"layerView.i3slayer"})],F.prototype,"layer",void 0),c([l({readOnly:!0})],F.prototype,"defaultQueryJSON",null),F=c([B("esri.views.3d.layers.i3s.I3SQueryEngine")],F);const et=F;class tt{constructor(t){this.objectIdField=t.objectIdField,this.getFeatureExtent=t.getFeatureExtent}getObjectId(t){return t.id}getAttributes(t){const{meta:r,index:s}=t,i={};this.objectIdField&&(i[this.objectIdField]=t.id);const n=b(r.attributeInfo)&&r.attributeInfo.attributeData;if(b(n))for(const a of Object.keys(n))i[a]=X(n[a],s);return i}getAttribute(t,r){if(r===this.objectIdField)return t.id;const{meta:s,index:i}=t,n=b(s.attributeInfo)&&s.attributeInfo.attributeData;return b(n)?X(n[r],i):null}getGeometry(t){if(t.geometry)return t.geometry;const[r,s,i,n,a]=this.getFeatureExtent(t,ee);return new P([5],[r,s,i,n,s,i,n,a,i,r,a,i,r,s,i])}getCentroid(t,r){if(t.geometry)return Me(new P,t.geometry,r.hasZ,r.hasM);const[s,i,n,a,o,d]=this.getFeatureExtent(t,ee);return new P([0],[(s+a)/2,(i+o)/2,(n+d)/2])}cloneWithGeometry(t,r){const{id:s,index:i,meta:n}=t;return{id:s,index:i,meta:n,geometry:r}}}const ee=K();let Q=class extends q{constructor(e){super(e),this.events=new _e}forEach(e){this.forAllFeatures(t=>(e(t),T.CONTINUE))}forEachBounds(e,t,r){const s=this.getFeatureExtent;for(const i of e)t(s(i,r))}forEachInBounds(e,t){this.forAllFeatures(r=>{const s=this.getFeatureExtent(r,Ke);return Qe(e,ve(s,qe))&&t(r),T.CONTINUE},r=>{if(Z(r.node.mbs,this.sourceSpatialReference,S,this.viewSpatialReference),S[0]>=e[0]&&S[2]<=e[2]&&S[1]>=e[1]&&S[3]<=e[3])return T.CONTINUE;const s=Math.max(e[0],Math.min(S[0],e[2])),i=Math.max(e[1],Math.min(S[1],e[3])),n=S[0]-s,a=S[1]-i;return n*n+a*a<=S[3]*S[3]?T.CONTINUE:T.SKIP})}};c([l({constructOnly:!0})],Q.prototype,"featureAdapter",void 0),c([l({constructOnly:!0})],Q.prototype,"forAllFeatures",void 0),c([l({constructOnly:!0})],Q.prototype,"getFeatureExtent",void 0),c([l({constructOnly:!0})],Q.prototype,"sourceSpatialReference",void 0),c([l({constructOnly:!0})],Q.prototype,"viewSpatialReference",void 0),Q=c([B("esri.views.3d.layers.i3s.I3SQueryFeatureStore")],Q);const S=je(),Ke=K(),qe=$e(),rt=Q;export{h as M,rt as a,et as d,tt as n};
