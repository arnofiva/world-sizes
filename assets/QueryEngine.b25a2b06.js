var fe=Object.defineProperty,ye=Object.defineProperties;var pe=Object.getOwnPropertyDescriptors;var Z=Object.getOwnPropertySymbols;var de=Object.prototype.hasOwnProperty,me=Object.prototype.propertyIsEnumerable;var J=(a,e,t)=>e in a?fe(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,H=(a,e)=>{for(var t in e||(e={}))de.call(e,t)&&J(a,t,e[t]);if(Z)for(var t of Z(e))me.call(e,t)&&J(a,t,e[t]);return a},L=(a,e)=>ye(a,pe(e));import{fg as xe,fh as _e,fi as A,fj as V,an as W,fk as $,fl as ge,fm as G,fn as Se,aa as d,fo as M,fp as we,fq as C,fr as Re,aI as ue,fs as Qe,dO as Ie,aZ as X,R as Y,ft as O,fu as Fe,eE as R,fv as Q,fw as I,fx as _,dY as Ee,dZ as $e,fy as Ge,fz as v,bT as q,fA as ve,fB as K,fC as ee,fD as te,L as B,J as se,aX as ie,fE as be,ey as re,fF as Ce,bs as Ae,bo as ke,fG as E,fH as Pe,fI as Te,fJ as ze}from"./vendor.d1b93dad.js";import{t as Oe}from"./QueryEngineCapabilities.650d7541.js";function qe(a){return a==="mesh"?xe:_e(a)}function le(a,e){return a?e?4:3:e?3:2}function Be(a,e,t,s){return ce(a,e,t,s.coords[0],s.coords[1])}function je(a,e,t,s,i,r){const o=le(i,r),{coords:u,lengths:n}=s;if(!n)return!1;for(let l=0,c=0;l<n.length;l++,c+=o)if(!ce(a,e,t,u[c],u[c+1]))return!1;return!0}function ce(a,e,t,s,i){if(!a)return!1;const r=le(e,t),{coords:o,lengths:u}=a;let n=!1,l=0;for(const c of u)n=Me(n,o,r,l,c,s,i),l+=c*r;return n}function Me(a,e,t,s,i,r,o){let u=a,n=s;for(let l=s,c=s+i*t;l<c;l+=t){n=l+t,n===c&&(n=s);const h=e[l],f=e[l+1],m=e[n],y=e[n+1];(f<o&&y>=o||y<o&&f>=o)&&h+(o-f)/(y-f)*(m-h)<r&&(u=!u)}return u}const j="feature-store:unsupported-query",Ne={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},N={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function De(a){return N.spatialRelationship[a]===!0}function Ue(a){return N.queryGeometry[we(a)]===!0}function Ze(a){return N.layerGeometry[a]===!0}function Je(){return import("./geometryEngineJSON.75aa89d4.js")}function ae(a,e,t,s,i){if(A(e)&&t==="esriGeometryPoint"&&(a==="esriSpatialRelIntersects"||a==="esriSpatialRelContains")){const r=V(new W,e,!1,!1);return Promise.resolve(o=>Be(r,!1,!1,o))}if(A(e)&&t==="esriGeometryMultipoint"){const r=V(new W,e,!1,!1);if(a==="esriSpatialRelContains")return Promise.resolve(o=>je(r,!1,!1,o,s,i))}if($(e)&&t==="esriGeometryPoint"&&(a==="esriSpatialRelIntersects"||a==="esriSpatialRelContains"))return Promise.resolve(r=>ge(e,G(t,s,i,r)));if($(e)&&t==="esriGeometryMultipoint"&&a==="esriSpatialRelContains")return Promise.resolve(r=>Se(e,G(t,s,i,r)));if($(e)&&a==="esriSpatialRelIntersects"){const r=qe(t);return Promise.resolve(o=>r(e,G(t,s,i,o)))}return Je().then(r=>{const o=r[Ne[a]].bind(null,e.spatialReference,e);return u=>o(G(t,s,i,u))})}async function ne(a,e,t){const{spatialRel:s,geometry:i}=a;if(i){if(!De(s))throw new d(j,"Unsupported query spatial relationship",{query:a});if(M(i.spatialReference)&&M(t)){if(!Ue(i))throw new d(j,"Unsupported query geometry type",{query:a});if(!Ze(e))throw new d(j,"Unsupported layer geometry type",{query:a});if(a.outSR)return C(a.geometry&&a.geometry.spatialReference,a.outSR)}}}function oe(a){if($(a))return!0;if(A(a)){for(const e of a.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}function He(a){return a.every(e=>e.statisticType!=="exceedslimit")}const g="feature-store:unsupported-query",b=new Set,Le=new Re(2e6);let Ve=0;class et{constructor(e){this.capabilities={query:Oe},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",()=>this.clearCache()),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new Qe(Ve+++"$$",Le)),this.fieldsIndex=new Ie(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=X(this._frameTask),this.clearCache(),Y(this._geometryQueryCache),this._changeHandle=X(this._changeHandle),Y(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:O(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=Fe(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e={},t){let s,i=R(e);try{i=await this._schedule(()=>Q(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t)}catch(r){if(r!==I)throw r;s=new _([],null,this)}return s.createQueryResponse(i)}async executeQueryForCount(e={},t){let s=R(e);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule(()=>Q(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t);let i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t);return i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t),i.createQueryResponseForCount(s)}catch(i){if(i!==I)throw i;return 0}}async executeQueryForExtent(e={},t){let s,i=R(e);const r=i.outSR;try{i=await this._schedule(()=>Q(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),i.returnGeometry=!0,i.returnCentroid=!1,i.outSR=null,s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t);const o=s.size;if(!o)return{count:o,extent:null};Ee(x,$e),this.featureStore.forEachBounds(s.items,l=>Ge(x,l),We);const u={xmin:x[0],ymin:x[1],xmax:x[3],ymax:x[4],spatialReference:O(this.spatialReference)};this.hasZ&&isFinite(x[2])&&isFinite(x[5])&&(u.zmin=x[2],u.zmax=x[5]);const n=v(u,s.spatialReference,r);if(n.spatialReference=O(r||this.spatialReference),n.xmax-n.xmin==0){const l=q(n.spatialReference);n.xmin-=l,n.xmax+=l}if(n.ymax-n.ymin==0){const l=q(n.spatialReference);n.ymin-=l,n.ymax+=l}if(this.hasZ&&n.zmin!=null&&n.zmax!=null&&n.zmax-n.zmin==0){const l=q(n.spatialReference);n.zmin-=l,n.zmax+=l}return{count:o,extent:n}}catch(o){if(o===I)return{count:0,extent:null};throw o}}async executeQueryForIds(e={},t){return this.executeQueryForIdSet(e,t).then(s=>Array.from(s))}async executeQueryForIdSet(e={},t){let s,i=R(e);i.returnGeometry=!1,i.returnCentroid=!1,i.outSR=null;try{i=await this._schedule(()=>Q(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t);const r=s.items,o=new Set;return await this._reschedule(()=>{for(const u of r)o.add(s.featureAdapter.getObjectId(u))},t),o}catch(r){if(r===I)return new Set;throw r}}async executeQueryForSnapping(e,t){const{point:s,distance:i,types:r}=e;if(r===ve.NONE)return{candidates:[]};const o=await this._reschedule(()=>this._checkQuerySupport(e.query),t),u=!K(s.spatialReference,this.spatialReference);u&&await C(s.spatialReference,this.spatialReference);const n=typeof i=="number"?i:i.x,l=typeof i=="number"?i:i.y,c={xmin:s.x-n,xmax:s.x+n,ymin:s.y-l,ymax:s.y+l,spatialReference:s.spatialReference},h=u?v(c,this.spatialReference):c;if(!h)return{candidates:[]};const f=(await ee(te(s),null,{signal:t}))[0],m=(await ee(te(h),null,{signal:t}))[0];if(B(f)||B(m))return{candidates:[]};let y=new _(this._searchFeatures(this._getQueryBBoxes(m.toJSON())),null,this);y=await this._reschedule(()=>y.executeObjectIdsQuery(o),t),y=await this._reschedule(()=>y.executeTimeQuery(o),t),y=await this._reschedule(()=>y.executeAttributesQuery(o),t);const w=f.toJSON(),k=u?v(w,this.spatialReference):w,P=u?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:i;return y.createSnappingResponse(L(H({},e),{point:k,distance:P}),s.spatialReference)}async executeQueryForLatestObservations(e={},t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new d(g,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});let s,i=R(e);try{i=await this._schedule(()=>Q(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t),s=await this._reschedule(()=>s.filterLatest(),t)}catch(r){if(r!==I)throw r;s=new _([],null,this)}return s.createQueryResponse(i)}async executeQueryForSummaryStatistics(e={},t,s){const{field:i,normalizationField:r,valueExpression:o}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:o},s)).createSummaryStatisticsResponse(e,t)}async executeQueryForUniqueValues(e={},t,s){const{field:i,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:i,valueExpression:r},s)).createUniqueValuesResponse(e,t)}async executeQueryForClassBreaks(e={},t,s){const{field:i,normalizationField:r,valueExpression:o}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:o},s)).createClassBreaksResponse(e,t)}async executeQueryForHistogram(e={},t,s){const{field:i,normalizationField:r,valueExpression:o}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:o},s)).createHistogramResponse(e,t)}async _schedule(e,t){return se(this._frameTask)?this._frameTask.schedule(e,t):e(ie)}async _reschedule(e,t){return se(this._frameTask)?this._frameTask.reschedule(e,t):e(ie)}_getAll(){if(!this._allItems){const e=[];this.featureStore.forEach(t=>e.push(t)),this._allItems=new _(e,null,this)}return this._allItems}async _executeGeometryQuery(e,t){const{geometry:s,outSR:i,spatialRel:r,returnGeometry:o,returnCentroid:u}=e,n=this.featureStore.featureSpatialReference,l=s&&n&&n!==s.spatialReference?v(s,n):s,c=o||u,h=M(i)&&!K(this.spatialReference,i),f=this._geometryQueryCache?h&&c?JSON.stringify({originalFilterGeometry:s,spatialRelationship:r,outSpatialReference:i}):JSON.stringify({originalFilterGeometry:s,spatialRelationship:r}):null;if(f){const p=this._geometryQueryCache.get(f);if(!be(p))return p}const m=async p=>{if(h&&c){const S=await p.project(i);return f&&this._geometryQueryCache.put(f,S,S.size||1),S}return f&&this._geometryQueryCache.put(f,p,p.size||1),p};if(!l)return m(this._getAll());const y=this.featureAdapter;if(r==="esriSpatialRelDisjoint"){const p=this._searchFeatures(this._getQueryBBoxes(s));if(!p.length)return m(this._getAll());let S,D;const T=new Set;for(const F of p)T.add(y.getObjectId(F));await this._reschedule(()=>{let F=0;S=new Array(T.size),this.featureStore.forEach(z=>S[F++]=z),D=T},t);const he=await this._reschedule(async()=>{const F=await ae(r,l,this.geometryType,this.hasZ,this.hasM),z=U=>!D.has(y.getObjectId(U))||F(y.getGeometry(U));return new _(await this._runSpatialFilter(S,z,t),s,this)},t);return m(he)}const w=this._searchFeatures(this._getQueryBBoxes(s));if(!w.length){const p=new _([],s,this);return f&&this._geometryQueryCache.put(f,p,p.size||1),p}if(this._canExecuteSoloPass(l,e))return m(new _(w,s,this));const k=await ae(r,l,this.geometryType,this.hasZ,this.hasM),P=await this._runSpatialFilter(w,p=>k(y.getGeometry(p)),t);return m(new _(P,s,this))}async _runSpatialFilter(e,t,s){if(!t)return e;if(B(this._frameTask))return e.filter(u=>t(u));let i=0;const r=new Array,o=async u=>{for(;i<e.length;){const n=e[i++];t(n)&&(r.push(n),u.madeProgress()),u.done&&await this._reschedule(l=>o(l),s)}};return this._reschedule(u=>o(u),s).then(()=>r)}_canExecuteSoloPass(e,t){const{geometryType:s}=this,{spatialRel:i}=t;return oe(e)&&(i==="esriSpatialRelEnvelopeIntersects"||s==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"||i==="esriSpatialRelWithin"))}_getQueryBBoxes(e){if(oe(e)){if($(e))return[re(e.xmin,e.ymin,e.xmax,e.ymax)];if(A(e))return e.rings.map(t=>re(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1])))}return[Ce(Ae(),e)]}_searchFeatures(e){for(const i of e)this.featureStore.forEachInBounds(i,r=>{b.add(r)});const t=new Array(b.size);let s=0;return b.forEach(i=>t[s++]=i),b.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new d(g,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsParamsSupport(t),ne(e,this.geometryType,this.spatialReference),C(this.spatialReference,e.outSR)]).then(()=>e)}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:s}=await ke();t=s.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new d(g,"params should have at least a field or valueExpression",{params:e});E(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new d(g,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),ne(e,this.geometryType,this.spatialReference),C(this.spatialReference,e.outSR)]).then(()=>e)}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:s,returnDistinctValues:i,outStatistics:r}=e,o=r?r.map(u=>u.outStatisticFieldName&&u.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if(s&&s.length>0){const u=" asc",n=" desc",l=s.map(c=>{const h=c.toLowerCase();return h.indexOf(u)>-1?h.split(u)[0]:h.indexOf(n)>-1?h.split(n)[0]:c}).filter(c=>o.indexOf(c)===-1);E(this.fieldsIndex,l,"orderByFields contains missing fields")}if(t&&t.length>0)E(this.fieldsIndex,t,"outFields contains missing fields");else if(i)throw new d(g,"outFields should be specified for returnDistinctValues",{query:e});Pe(this.fieldsIndex,e.where)}async _checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:s,having:i}=e,r=s&&s.length,o=t&&t.length;if(i){if(!r||!o)throw new d(g,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});Te(this.fieldsIndex,i,t)}if(o){if(!He(t))return;const u=t.map(n=>n.onStatisticField).filter(Boolean);E(this.fieldsIndex,u,"onStatisticFields contains missing fields"),r&&E(this.fieldsIndex,s,"groupByFieldsForStatistics contains missing fields");for(const n of t){const{onStatisticField:l,statisticType:c}=n;if((c==="percentile_disc"||c==="percentile_cont")&&"statisticParameters"in n){const{statisticParameters:h}=n;if(!h)throw new d(g,"statisticParamters should be set for percentile type",{definition:n,query:e})}else if(c!=="count"&&l&&ze(l,this.fieldsIndex))throw new d(g,"outStatistics contains non-numeric fields",{definition:n,query:e})}}}async _getQueryEngineResultForStats(e={},t,s){let i;e=R(e);try{e=await this._schedule(()=>Q(e,this.definitionExpression,this.spatialReference),s),e=await this._reschedule(()=>this._checkStatisticsSupport(e,t),s),i=await this._reschedule(()=>this._executeGeometryQuery(e,s),s),i=await this._reschedule(()=>i.executeAggregateIdsQuery(e),s),i=await this._reschedule(()=>i.executeObjectIdsQuery(e),s),i=await this._reschedule(()=>i.executeTimeQuery(e),s),i=await this._reschedule(()=>i.executeAttributesQuery(e),s)}catch(r){if(r!==I)throw r;i=new _([],null,this)}return i}}const We=ue(),x=ue();export{et as V,ae as v};
