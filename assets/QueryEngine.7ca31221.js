var it=Object.defineProperty,st=Object.defineProperties;var rt=Object.getOwnPropertyDescriptors;var Se=Object.getOwnPropertySymbols;var at=Object.prototype.hasOwnProperty,nt=Object.prototype.propertyIsEnumerable;var Ie=(n,e,t)=>e in n?it(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Y=(n,e)=>{for(var t in e||(e={}))at.call(e,t)&&Ie(n,t,e[t]);if(Se)for(var t of Se(e))nt.call(e,t)&&Ie(n,t,e[t]);return n},re=(n,e)=>st(n,rt(e));import{e_ as ot,e$ as lt,f0 as D,f1 as je,f2 as pe,f3 as Oe,r as j,bu as ut,f4 as J,f5 as Fe,L as F,t as z,dC as ct,a1 as X,f6 as ue,f7 as ce,f8 as he,ee as ht,f9 as ft,fa as Re,fb as fe,fc as de,fd as dt,fe as mt,ff as pt,fg as yt,fh as gt,fi as xt,fj as be,fk as ve,fl as _t,fm as wt,fn as St,b3 as qe,fo as It,fp as Ft,fq as se,fr as Ae,fs as W,ft as Rt,fu as bt,fv as vt,fw as At,am as Be,fx as Tt,du as Et,aD as Te,p as Ee,em as Z,dF as zt,dG as $t,fy as Qt,by as ae,aB as ze,fz as Vt,eg as $e,fA as Gt,b7 as Ct}from"./vendor.f59113c8.js";import{WhereClause as Mt}from"./WhereClause.d621a470.js";import{t as Ze}from"./json.da51edc4.js";import{t as Pt}from"./QueryEngineCapabilities.650d7541.js";import{T as Nt,s as Dt,m as Qe,c as Ve,V as jt,g as Ot,h as qt,y as Bt,D as Zt,z as kt,f as Ut,d as Lt}from"./utils.a947722b.js";const ne=[0,0];function ke(n,e){if(!e)return null;if("x"in e){const t={x:0,y:0};return[t.x,t.y]=n(e.x,e.y,ne),e.z!=null&&(t.z=e.z),e.m!=null&&(t.m=e.m),t}if("xmin"in e){const t={xmin:0,ymin:0,xmax:0,ymax:0};return[t.xmin,t.ymin]=n(e.xmin,e.ymin,ne),[t.xmax,t.ymax]=n(e.xmax,e.ymax,ne),e.hasZ&&(t.zmin=e.zmin,t.zmax=e.zmax,t.hasZ=!0),e.hasM&&(t.mmin=e.mmin,t.mmax=e.mmax,t.hasM=!0),t}return"rings"in e?{rings:Ge(e.rings,n),hasM:e.hasM,hasZ:e.hasZ}:"paths"in e?{paths:Ge(e.paths,n),hasM:e.hasM,hasZ:e.hasZ}:"points"in e?{points:Ue(e.points,n),hasM:e.hasM,hasZ:e.hasZ}:void 0}function Ge(n,e){const t=[];for(const i of n)t.push(Ue(i,e));return t}function Ue(n,e){const t=[];for(const i of n){const s=e(i[0],i[1],[0,0]);t.push(s),i.length>2&&s.push(i[2]),i.length>3&&s.push(i[3])}return t}async function L(n,e){if(!e)return;const t=Array.isArray(n)?n.map(i=>j(i.geometry)&&i.geometry.spatialReference):[n];await ut(t.map(i=>({source:i,dest:e})))}const Le=ke.bind(null,ot),He=ke.bind(null,lt);function C(n,e,t){if(!n||(t||(t=e,e=n.spatialReference),!J(e)||!J(t)||D(e,t)))return n;if(je(e,t)){const i=pe(t)?Le(n):He(n);return i.spatialReference=t,i}return Oe(Ze,[n],e,t,null)[0]}class Ht{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(e,t,i){if(!e||!e.length||!t||!i||D(t,i))return e;const s={geometries:e,inSpatialReference:t,outSpatialReference:i,resolve:null};return this._jobs.push(s),new Promise(r=>{s.resolve=r,this._timer===null&&(this._timer=setTimeout(this._process,10))})}_process(){this._timer=null;const e=this._jobs.shift();if(!e)return;const{geometries:t,inSpatialReference:i,outSpatialReference:s,resolve:r}=e;je(i,s)?pe(s)?r(t.map(Le)):r(t.map(He)):r(Oe(Ze,t,i,s,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}}const Jt=new Ht;function Yt(n,e,t){return Jt.push(n,e,t)}class Wt{constructor(e,t){this._cache=new Fe(e),this._invalidCache=new Fe(t)}get(e,t){const i=`${t.uid}:${e}`,s=this._cache.get(i);if(s)return s;if(this._invalidCache.get(i)!==void 0)return null;try{const r=Mt.create(e,t);return this._cache.put(i,r),r}catch{return this._invalidCache.put(i,null),null}}}const ye=new Wt(50,500),P="feature-store:unsupported-query",Je=" as ",Xt=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function Kt(n,e){if(!e)return!0;const t=ye.get(e,n);if(!t)throw new F(P,"invalid SQL expression",{where:e});if(!t.isStandardized)throw new F(P,"where clause is not standard",{where:e});return G(n,t.fieldNames,"where clause contains missing fields"),!0}function ei(n,e,t){if(!e)return!0;const i=ye.get(e,n);if(!i)throw new F(P,"invalid SQL expression",{having:e});if(!i.isAggregate)throw new F(P,"having does not contain a valid aggregate function",{having:e});const s=i.fieldNames;if(G(n,s,"having contains missing fields"),!i.getExpressions().every(r=>{const{aggregateType:a,field:o}=r,l=n.has(o)&&n.get(o).name;return t.some(u=>{const{onStatisticField:c,statisticType:h}=u;return(n.has(c)&&n.get(c).name)===l&&h.toLowerCase().trim()===a})}))throw new F(P,"expressions in having should also exist in outStatistics",{having:e});return!0}function U(n,e){return n?ye.get(n,e):null}function G(n,e,t,i=!0){const s=[];for(const r of e)if(r!=="*"&&!n.has(r))if(i){const a=Ye(r);try{const o=U(a,n);if(!o)throw new F(P,"invalid SQL expression",{where:a});if(!o.isStandardized)throw new F(P,"expression is not standard",{clause:o});G(n,o.fieldNames,"expression contains missing fields")}catch(o){const l=o&&o.details;if(l&&(l.clause||l.where))throw o;l&&l.missingFields?s.push(...l.missingFields):s.push(r)}}else s.push(r);if(s.length)throw new F(P,t,{missingFields:s})}function Ye(n){return n.split(Je)[0]}function ti(n){return n.split(Je)[1]}function ii(n,e){const t=e.get(n);return!!t&&!Xt.has(t.type)}class te{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues,this.fieldsIndex=i,this.featureAdapter=t;const s=e.outFields;if(s&&s.indexOf("*")===-1){this.outFields=s;let r=0;for(const a of s){const o=Ye(a),l=this.fieldsIndex.get(o),u=l?null:U(o,i),c=l?l.name:ti(a)||"FIELD_EXP_"+r++;this._fieldDataCache.set(a,{alias:c,clause:u})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){const s=i?i.name:t;let r=null;return this._fieldDataCache.has(s)?r=this._fieldDataCache.get(s).clause:i||(r=U(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:r})),i?this.featureAdapter.getAttribute(e,s):r.calculateValue(e,this.featureAdapter)}getNormalizedValue(e,t){const i=t.normalizationType,s=t.normalizationTotal;let r=this.getFieldValue(e,t.field,t.fieldInfo);if(i&&Number.isFinite(r)){const a=this.getFieldValue(e,t.normalizationField,t.normalizationFieldInfo);r=Nt(r,i,a,s)}return r}getExpressionValue(e,t,i){const s={attributes:this.featureAdapter.getAttributes(e)},r=i.createExecContext(s,t.viewInfo);return i.executeFunction(t.compiledFunc,r)}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:U(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testFeature(e,this.featureAdapter)}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:U(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testSet(e,this.featureAdapter)}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const i={};for(const s of t){const{alias:r,clause:a}=this._fieldDataCache.get(s);i[r]=a?a.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,r)}return i}_processAttributesForDistinctValues(e){if(z(e)||!this.returnDistinctValues)return e;const t=this.outFields,i=[];if(t)for(const a of t){const{alias:o}=this._fieldDataCache.get(a);i.push(e[o])}else for(const a in e)i.push(e[a]);const s=`${(t||["*"]).join(",")}=${i.join(",")}`;let r=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++r),r>1?null:e}}function si(n,e){if(!n)return null;const t=e.featureAdapter,{startTimeField:i,endTimeField:s}=n;let r=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;if(i&&s)e.forEach(o=>{const l=t.getAttribute(o,i),u=t.getAttribute(o,s);l==null||isNaN(l)||(r=Math.min(r,l)),u==null||isNaN(u)||(a=Math.max(a,u))});else{const o=i||s;e.forEach(l=>{const u=t.getAttribute(l,o);u==null||isNaN(u)||(r=Math.min(r,u),a=Math.max(a,u))})}return{start:r,end:a}}function ri(n,e,t){if(!e||!n)return null;const{startTimeField:i,endTimeField:s}=n;if(!i&&!s)return null;const{start:r,end:a}=e;return r===null&&a===null?null:r===void 0&&a===void 0?oi():i&&s?ai(t,i,s,r,a):ni(t,i||s,r,a)}function ai(n,e,t,i,s){return i!=null&&s!=null?r=>{const a=n.getAttribute(r,e),o=n.getAttribute(r,t);return(a==null||a<=s)&&(o==null||o>=i)}:i!=null?r=>{const a=n.getAttribute(r,t);return a==null||a>=i}:s!=null?r=>{const a=n.getAttribute(r,e);return a==null||a<=s}:void 0}function ni(n,e,t,i){return t!=null&&i!=null&&t===i?s=>n.getAttribute(s,e)===t:t!=null&&i!=null?s=>{const r=n.getAttribute(s,e);return r>=t&&r<=i}:t!=null?s=>n.getAttribute(s,e)>=t:i!=null?s=>n.getAttribute(s,e)<=i:void 0}function oi(){return()=>!1}const li=new ct({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),V=Object.freeze({}),Ce=new X,ui=new X,me=new X,oe={esriGeometryPoint:de,esriGeometryPolyline:pt,esriGeometryPolygon:yt,esriGeometryMultipoint:gt};function Me(n,e,t,i=n.hasZ,s=n.hasM){if(z(e))return null;const r=n.hasZ&&i,a=n.hasM&&s;if(t){const o=fe(me,e,n.hasZ,n.hasM,"esriGeometryPoint",t,i,s);return de(o,r,a)}return de(e,r,a)}function M(n,e,t,i,s,r,a=e,o=t){const l=e&&a,u=t&&o,c=j(i)?"coords"in i?i:i.geometry:null;if(z(c))return null;if(s){let h=dt(ui,c,e,t,n,s,a,o);return r&&(h=fe(me,h,l,u,n,r)),oe[n](h,l,u)}if(r){const h=fe(me,c,e,t,n,r,a,o);return oe[n](h,l,u)}return mt(Ce,c,e,t,a,o),oe[n](Ce,l,u)}async function k(n,e,t){const{outFields:i,orderByFields:s,groupByFieldsForStatistics:r,outStatistics:a}=n;if(i)for(let o=0;o<i.length;o++)i[o]=i[o].trim();if(s)for(let o=0;o<s.length;o++)s[o]=s[o].trim();if(r)for(let o=0;o<r.length;o++)r[o]=r[o].trim();if(a)for(let o=0;o<a.length;o++)a[o].onStatisticField&&(a[o].onStatisticField=a[o].onStatisticField.trim());return n.geometry&&!n.outSR&&(n.outSR=n.geometry.spatialReference),ci(n,e,t)}async function ci(n,e,t){if(!n)return null;let{where:i}=n;if(n.where=i=i&&i.trim(),(!i||/^1 *= *1$/.test(i)||e&&e===i)&&(n.where=null),!n.geometry)return n;let s=await hi(n);if(n.distance=0,n.units=null,n.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:l}=n.geometry;s=ue(s),s.spatialReference=l}n.geometry=s,await L(s.spatialReference,t);const r=(await ce(he(s)))[0];if(z(r))throw V;const a=r.toJSON(),o=await C(a,a.spatialReference,t);if(!o)throw V;return o.spatialReference=t,n.geometry=o,n}async function hi(n){const{geometry:e,distance:t,units:i}=n;if(t==null||"vertexAttributes"in e)return e;const s=e.spatialReference,r=i?li.fromJSON(i):ht(s),a=s&&(ft(s)||pe(s))?e:await L(s,Re).then(()=>C(e,Re));return(await fi())(a.spatialReference,a,t,r)}async function fi(){return(await import("./geometryEngineJSON.1eda2436.js")).geodesicBuffer}function H(n){return n&&We in n?JSON.parse(JSON.stringify(n,di)):n}const We="_geVersion",di=(n,e)=>n!==We?e:void 0;class R{constructor(e,t,i){this.items=e,this.queryGeometry=t,this.definitionExpression=i.definitionExpression,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.fieldsIndex=i.fieldsIndex,this.timeInfo=i.timeInfo,this.featureAdapter=i.featureAdapter,this.aggregateAdapter=i.aggregateAdapter}get size(){return this.items.length}createQueryResponseForCount(e){const t=new te(e,this.featureAdapter,this.fieldsIndex);if(!e.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:i,having:s}=e;if(!(i==null?void 0:i.length))return 1;const r=new Map,a=new Map,o=new Set,l=e.outStatistics;for(const u of l){const{statisticType:c}=u,h=c!=="exceedslimit"?u.onStatisticField:void 0;if(!a.has(h)){const m=[];for(const f of i){const _=this._getAttributeValues(t,f,r);m.push(_)}a.set(h,this._calculateUniqueValues(m,t.returnDistinctValues))}const d=a.get(h);for(const m in d){const{data:f,items:_}=d[m],S=f.join(",");s&&!t.validateItems(_,s)||o.add(S)}}return o.size}async createQueryResponse(e){let t;return e.outStatistics?t=e.outStatistics.some(i=>i.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(e):await this._createStatisticsQueryResponse(e):t=this._createFeatureQueryResponse(e),e.returnQueryGeometry&&(J(e.outSR)&&!D(this.queryGeometry.spatialReference,e.outSR)?t.queryGeometry=H(Y({spatialReference:e.outSR},C(this.queryGeometry,this.queryGeometry.spatialReference,e.outSR))):t.queryGeometry=H(Y({spatialReference:e.outSR},this.queryGeometry))),t}createSnappingResponse(e,t){const i=this.featureAdapter,s=pi(this.hasZ,this.hasM),{x:r,y:a}=e.point,o=typeof e.distance=="number"?e.distance:e.distance.x,l=typeof e.distance=="number"?e.distance:e.distance.y,u={candidates:[]},c=this.geometryType==="esriGeometryPolygon",h=this._getPointCreator(e.point,this.spatialReference,t);for(const d of this.items){const m=i.getGeometry(d);if(z(m))continue;const{coords:f,lengths:_}=m;if(e.types&K.EDGE){let S=0;for(let w=0;w<_.length;w++){const p=_[w];for(let x=0;x<p;x++,S+=s){const I=f[S],y=f[S+1];if(x!==p-1){const g=f[S+s],b=f[S+s+1],{x:T,y:N}=mi(r,a,I,y,g,b),v=(r-T)/o,E=(a-N)/l,O=v*v+E*E;O<=1&&u.candidates.push({type:"edge",objectId:i.getObjectId(d),distance:Math.sqrt(O),target:h(T,N),start:h(I,y),end:h(g,b)})}}}}if(e.types&K.VERTEX){const S=c?f.length-s:f.length;for(let w=0;w<S;w+=s){const p=f[w],x=f[w+1],I=(r-p)/o,y=(a-x)/l,g=I*I+y*y;g<=1&&u.candidates.push({type:"vertex",objectId:i.getObjectId(d),distance:Math.sqrt(g),target:h(p,x)})}}}return u.candidates.sort((d,m)=>d.distance-m.distance),u}_getPointCreator(e,t,i){const s=j(i)&&!D(t,i)?r=>C(r,t,i):r=>r;return e.z!=null&&e.m!=null?(r,a)=>s({x:r,y:a,z:e.z,m:e.m}):e.z!=null?(r,a)=>s({x:r,y:a,z:e.z}):e.m!=null?(r,a)=>s({x:r,y:a,m:e.m}):(r,a)=>s({x:r,y:a})}executeAttributesQuery(e){const t=U(e.where,this.fieldsIndex);if(!t)return Promise.resolve(this);if(t.isStandardized){let i=0;const s=[];for(const a of this.items)t.testFeature(a,this.featureAdapter)&&(s[i++]=a);const r=new R(s,this.queryGeometry,this);return r.definitionExpression=e.where,Promise.resolve(r)}return Promise.reject(new TypeError("Where clause is not standardized"))}executeAggregateIdsQuery(e){if(!e.aggregateIds||!e.aggregateIds.length||z(this.aggregateAdapter))return Promise.resolve(this);const t=new Set;for(const s of e.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach(r=>t.add(r));const i=this.featureAdapter.getObjectId;return Promise.resolve(new R(this.items.filter(s=>t.has(i(s))),this.queryGeometry,this))}executeObjectIdsQuery(e){if(!e.objectIds||!e.objectIds.length)return Promise.resolve(this);const t=new Set(e.objectIds),i=this.featureAdapter.getObjectId;return Promise.resolve(new R(this.items.filter(s=>t.has(i(s))),this.queryGeometry,this))}executeTimeQuery(e){const t=ri(this.timeInfo,e.timeExtent,this.featureAdapter);if(!j(t))return Promise.resolve(this);const i=this.items.filter(t);return Promise.resolve(new R(i,this.queryGeometry,this))}filterLatest(){const{trackIdField:e,startTimeField:t,endTimeField:i}=this.timeInfo,s=i||t,r=new Map,a=this.featureAdapter.getAttribute;for(const l of this.items){const u=a(l,e),c=a(l,s),h=r.get(u);(!h||c>a(h,s))&&r.set(u,l)}const o=Array.from(r.values());return Promise.resolve(new R(o,this.queryGeometry,this))}async project(e){if(!e||D(this.spatialReference,e))return this;const t=this.featureAdapter,i=(await Yt(this.items.map(s=>M(this.geometryType,this.hasZ,this.hasM,t.getGeometry(s))),this.spatialReference,e)).map((s,r)=>t.cloneWithGeometry(this.items[r],xt(s,this.hasZ,this.hasM)));return new R(i,this.queryGeometry,{definitionExpression:this.definitionExpression,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,objectIdField:this.objectIdField,spatialReference:e,fieldsIndex:this.fieldsIndex,timeInfo:this.timeInfo,featureAdapter:this.featureAdapter})}async createSummaryStatisticsResponse(e,t){const{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,minValue:l,maxValue:u,scale:c}=t,h=this.fieldsIndex.isDateField(i),d=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,scale:c}),m=Dt({normalizationType:a,normalizationField:r,minValue:l,maxValue:u}),f=this.fieldsIndex.get(i),_={value:.5,fieldType:f==null?void 0:f.type},S=be(f)?Qe({values:d,supportsNullCount:m,percentileParams:_}):Ve({values:d,minValue:l,maxValue:u,useSampleStdDev:!a,supportsNullCount:m,percentileParams:_});return jt(S,h)}async createUniqueValuesResponse(e,t){const{field:i,valueExpression:s,domain:r,returnAllCodedValues:a,scale:o}=t,l=await this._getDataValues(e,{field:i,valueExpression:s,scale:o}),u=Ot(l);return qt(u,r,a)}async createClassBreaksResponse(e,t){const{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numClasses:d,scale:m}=t,f=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,scale:m}),_=Bt(f,{field:i,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numClasses:d});return Zt(_,l)}async createHistogramResponse(e,t){const{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numBins:d,scale:m}=t,f=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,scale:m});return kt(f,{field:i,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numBins:d})}_sortFeatures(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const r=s.split(" "),a=r[0],o=this.fieldsIndex.get(a),l=r[1]&&r[1].toLowerCase()==="desc",u=Ut(o==null?void 0:o.type,l);e.sort((c,h)=>{const d=i(c,a,o),m=i(h,a,o);return u(d,m)})}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:i,hasM:s,hasZ:r,objectIdField:a,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:h,resultOffset:d,returnZ:m,returnM:f}=e,_=h!=null&&t.length>(d||0)+h,S=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map(w=>this.fieldsIndex.get(w)));return{exceededTransferLimit:_,features:this._createFeatures(e,t),fields:S,geometryType:i,hasM:s&&f,hasZ:r&&m,objectIdFieldName:a,spatialReference:H(u||o),transform:c&&ve(c)||null}}_createFeatures(e,t){const i=new te(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:r}=this,{orderByFields:a,quantizationParameters:o,returnGeometry:l,returnCentroid:u,maxAllowableOffset:c,resultOffset:h,resultRecordCount:d,returnZ:m=!1,returnM:f=!1}=e,_=r&&m,S=s&&f;let w=[],p=0;const x=[...t];if(this._sortFeatures(x,a,(y,g,b)=>i.getFieldValue(y,g,b)),l||u){const y=ve(o);if(l&&!u)for(const g of x)w[p++]={attributes:i.getAttributes(g),geometry:M(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),c,y,_,S)};else if(!l&&u)for(const g of x)w[p++]={attributes:i.getAttributes(g),centroid:Me(this,this.featureAdapter.getCentroid(g,this),y)};else for(const g of x)w[p++]={attributes:i.getAttributes(g),centroid:Me(this,this.featureAdapter.getCentroid(g,this),y),geometry:M(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),c,y,_,S)}}else for(const y of x){const g=i.getAttributes(y);g&&(w[p++]={attributes:g})}const I=h||0;if(d!=null){const y=I+d;w=w.slice(I,Math.min(w.length,y))}return w}_createExceedsLimitQueryResponse(e){let t=!1,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(const a of e.outStatistics)if(a.statisticType==="exceedslimit"){i=a.maxPointCount!=null?a.maxPointCount:Number.POSITIVE_INFINITY,s=a.maxRecordCount!=null?a.maxRecordCount:Number.POSITIVE_INFINITY,r=a.maxVertexCount!=null?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")t=this.items.length>i;else if(this.items.length>s)t=!0;else{const a=this.hasZ?this.hasM?4:3:this.hasM?3:2,o=this.featureAdapter;t=this.items.reduce((l,u)=>{const c=o.getGeometry(u);return l+(j(c)&&c.coords.length||0)},0)/a>r}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},i=[],s=new Map,r=new Map,a=new Map,o=new Map,l=new te(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:h,orderByFields:d}=e,m=c&&c.length,f=!!m,_=f&&c[0],S=f&&!this.fieldsIndex.get(_);for(const p of u){const{outStatisticFieldName:x,statisticType:I}=p,y=p,g=I!=="exceedslimit"?p.onStatisticField:void 0,b=I==="percentile_disc"||I==="percentile_cont",T=I==="EnvelopeAggregate"||I==="CentroidAggregate"||I==="ConvexHullAggregate",N=f&&m===1&&(g===_||S)&&I==="count";if(f){if(!a.has(g)){const E=[];for(const O of c){const ee=this._getAttributeValues(l,O,s);E.push(ee)}a.set(g,this._calculateUniqueValues(E,l.returnDistinctValues))}const v=a.get(g);for(const E in v){const{count:O,data:ee,items:xe,itemPositions:et}=v[E],_e=ee.join(",");if(!h||l.validateItems(xe,h)){const q=o.get(_e)||{attributes:{}};if(T){q.aggregateGeometries||(q.aggregateGeometries={});const{aggregateGeometries:$,outStatisticFieldName:B}=await this._getAggregateGeometry(y,xe);q.aggregateGeometries[B]=$}else{let $=null;if(N)$=O;else{const B=this._getAttributeValues(l,g,s),we=et.map(tt=>B[tt]);$=b&&"statisticParameters"in y?this._getPercentileValue(y,we):this._getStatisticValue(y,we,null,l.returnDistinctValues)}q.attributes[x]=$}c.forEach(($,B)=>q.attributes[this.fieldsIndex.get($)?$:`EXPR_${B+1}`]=ee[B]),o.set(_e,q)}}}else if(T){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:v,outStatisticFieldName:E}=await this._getAggregateGeometry(y,this.items);t.aggregateGeometries[E]=v}else{const v=this._getAttributeValues(l,g,s);t.attributes[x]=b&&"statisticParameters"in y?this._getPercentileValue(y,v):this._getStatisticValue(y,v,r,l.returnDistinctValues)}i.push({name:x,alias:x,type:"esriFieldTypeDouble"})}const w=f?Array.from(o.values()):[t];return this._sortFeatures(w,d,(p,x)=>p.attributes[x]),{fields:i,features:w}}async _getAggregateGeometry(e,t){const i=await import("./geometryEngineJSON.1eda2436.js"),{statisticType:s,outStatisticFieldName:r}=e,{featureAdapter:a,spatialReference:o,geometryType:l,hasZ:u,hasM:c}=this,h=t.map(f=>M(l,u,c,a.getGeometry(f))),d=i.convexHull(o,h,!0)[0],m={aggregateGeometries:null,outStatisticFieldName:null};if(s==="EnvelopeAggregate"){const f=d?_t(d):ue(i.union(o,h));m.aggregateGeometries=re(Y({},f),{spatialReference:o}),m.outStatisticFieldName=r||"extent"}else if(s==="CentroidAggregate"){const f=d?wt(d):St(ue(i.union(o,h)));m.aggregateGeometries={x:f[0],y:f[1],spatialReference:o},m.outStatisticFieldName=r||"centroid"}else s==="ConvexHullAggregate"&&(m.aggregateGeometries=d,m.outStatisticFieldName=r||"convexHull");return m}_getStatisticValue(e,t,i,s){const{onStatisticField:r,statisticType:a}=e;let o=null;return o=i!=null&&i.has(r)?i.get(r):be(this.fieldsIndex.get(r))?Qe({values:t,returnDistinct:s}):Ve({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(r,o),o[a==="var"?"variance":a]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:r}=e,{value:a,orderBy:o}=s,l=this.fieldsIndex.get(i),u={value:a,orderBy:o,fieldType:l==null?void 0:l.type,isDiscrete:r==="percentile_disc"};return Lt(t,u)}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),r=this.items.map(a=>e.getFieldValue(a,t,s));return i.set(t,r),r}_getAttributeNormalizedValues(e,t){return this.items.map(i=>e.getNormalizedValue(i,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal}))}async _getAttributeExpressionValues(e,t,i){const{arcadeUtils:s}=await qe(),r=s.createFunction(t),a=i&&s.getViewInfo(i);return this.items.map(o=>e.getExpressionValue(o,{compiledFunc:r,viewInfo:a},s))}_calculateUniqueValues(e,t){const i={},s=this.items,r=s.length;for(let a=0;a<r;a++){const o=s[a],l=[];for(const c of e)l.push(c[a]);const u=l.join(",");t?i[u]==null&&(i[u]={count:1,data:l,items:[o],itemPositions:[a]}):i[u]==null?i[u]={count:1,data:l,items:[o],itemPositions:[a]}:(i[u].count++,i[u].items.push(o),i[u].itemPositions.push(a))}return i}async _getDataValues(e,t){const i=new te(e,this.featureAdapter,this.fieldsIndex),{valueExpression:s,field:r,normalizationField:a,normalizationType:o,normalizationTotal:l,scale:u}=t,c=s?{viewingMode:"map",scale:u,spatialReference:e.outSR||this.spatialReference}:null;return s?this._getAttributeExpressionValues(i,s,c):this._getAttributeNormalizedValues(i,{field:r,normalizationField:a,normalizationType:o,normalizationTotal:l})}}function mi(n,e,t,i,s,r){const a=s-t,o=r-i,l=a*a+o*o,u=(n-t)*a+(e-i)*o,c=Math.min(1,Math.max(0,u/l));return{x:t+a*c,y:i+o*c}}function pi(n,e){return n?e?4:3:e?3:2}var K;(function(n){n[n.NONE=0]="NONE",n[n.EDGE=1]="EDGE",n[n.VERTEX=2]="VERTEX"})(K||(K={}));function yi(n){return n==="mesh"?It:Ft(n)}function Xe(n,e){return n?e?4:3:e?3:2}function gi(n,e,t,i){return Ke(n,e,t,i.coords[0],i.coords[1])}function xi(n,e,t,i,s,r){const a=Xe(s,r),{coords:o,lengths:l}=i;if(!l)return!1;for(let u=0,c=0;u<l.length;u++,c+=a)if(!Ke(n,e,t,o[c],o[c+1]))return!1;return!0}function Ke(n,e,t,i,s){if(!n)return!1;const r=Xe(e,t),{coords:a,lengths:o}=n;let l=!1,u=0;for(const c of o)l=_i(l,a,r,u,c,i,s),u+=c*r;return l}function _i(n,e,t,i,s,r,a){let o=n,l=i;for(let u=i,c=i+s*t;u<c;u+=t){l=u+t,l===c&&(l=i);const h=e[u],d=e[u+1],m=e[l],f=e[l+1];(d<a&&f>=a||f<a&&d>=a)&&h+(a-d)/(f-d)*(m-h)<r&&(o=!o)}return o}const le="feature-store:unsupported-query",wi={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},ge={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function Si(n){return ge.spatialRelationship[n]===!0}function Ii(n){return ge.queryGeometry[vt(n)]===!0}function Fi(n){return ge.layerGeometry[n]===!0}function Ri(){return import("./geometryEngineJSON.1eda2436.js")}function Pe(n,e,t,i,s){if(se(e)&&t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains")){const r=Ae(new X,e,!1,!1);return Promise.resolve(a=>gi(r,!1,!1,a))}if(se(e)&&t==="esriGeometryMultipoint"){const r=Ae(new X,e,!1,!1);if(n==="esriSpatialRelContains")return Promise.resolve(a=>xi(r,!1,!1,a,i,s))}if(W(e)&&t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains"))return Promise.resolve(r=>Rt(e,M(t,i,s,r)));if(W(e)&&t==="esriGeometryMultipoint"&&n==="esriSpatialRelContains")return Promise.resolve(r=>bt(e,M(t,i,s,r)));if(W(e)&&n==="esriSpatialRelIntersects"){const r=yi(t);return Promise.resolve(a=>r(e,M(t,i,s,a)))}return Ri().then(r=>{const a=r[wi[n]].bind(null,e.spatialReference,e);return o=>a(M(t,i,s,o))})}async function Ne(n,e,t){const{spatialRel:i,geometry:s}=n;if(s){if(!Si(i))throw new F(le,"Unsupported query spatial relationship",{query:n});if(J(s.spatialReference)&&J(t)){if(!Ii(s))throw new F(le,"Unsupported query geometry type",{query:n});if(!Fi(e))throw new F(le,"Unsupported layer geometry type",{query:n});if(n.outSR)return L(n.geometry&&n.geometry.spatialReference,n.outSR)}}}function De(n){if(W(n))return!0;if(se(n)){for(const e of n.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}function bi(n){return n.every(e=>e.statisticType!=="exceedslimit")}const Q="feature-store:unsupported-query",ie=new Set,vi=new At(2e6);let Ai=0;class Ci{constructor(e){this.capabilities={query:Pt},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",()=>this.clearCache()),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new Tt(Ai+++"$$",vi)),this.fieldsIndex=new Et(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=Te(this._frameTask),this.clearCache(),Ee(this._geometryQueryCache),this._changeHandle=Te(this._changeHandle),Ee(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:H(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=si(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e={},t){let i,s=Z(e);try{s=await this._schedule(()=>k(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t)}catch(r){if(r!==V)throw r;i=new R([],null,this)}return i.createQueryResponse(s)}async executeQueryForCount(e={},t){let i=Z(e);i.returnGeometry=!1,i.returnCentroid=!1,i.outSR=null;try{i=await this._schedule(()=>k(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t);let s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t);return s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t),s.createQueryResponseForCount(i)}catch(s){if(s!==V)throw s;return 0}}async executeQueryForExtent(e={},t){let i,s=Z(e);const r=s.outSR;try{s=await this._schedule(()=>k(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),s.returnGeometry=!0,s.returnCentroid=!1,s.outSR=null,i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t);const a=i.size;if(!a)return{count:a,extent:null};zt(A,$t),this.featureStore.forEachBounds(i.items,u=>Qt(A,u),Ti);const o={xmin:A[0],ymin:A[1],xmax:A[3],ymax:A[4],spatialReference:H(this.spatialReference)};this.hasZ&&isFinite(A[2])&&isFinite(A[5])&&(o.zmin=A[2],o.zmax=A[5]);const l=C(o,i.spatialReference,r);if(l.spatialReference=H(r||this.spatialReference),l.xmax-l.xmin==0){const u=ae(l.spatialReference);l.xmin-=u,l.xmax+=u}if(l.ymax-l.ymin==0){const u=ae(l.spatialReference);l.ymin-=u,l.ymax+=u}if(this.hasZ&&l.zmin!=null&&l.zmax!=null&&l.zmax-l.zmin==0){const u=ae(l.spatialReference);l.zmin-=u,l.zmax+=u}return{count:a,extent:l}}catch(a){if(a===V)return{count:0,extent:null};throw a}}async executeQueryForIds(e={},t){return this.executeQueryForIdSet(e,t).then(i=>Array.from(i))}async executeQueryForIdSet(e={},t){let i,s=Z(e);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule(()=>k(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t);const r=i.items,a=new Set;return await this._reschedule(()=>{for(const o of r)a.add(i.featureAdapter.getObjectId(o))},t),a}catch(r){if(r===V)return new Set;throw r}}async executeQueryForSnapping(e,t){const{point:i,distance:s,types:r}=e;if(r===K.NONE)return{candidates:[]};const a=await this._reschedule(()=>this._checkQuerySupport(e.query),t),o=!D(i.spatialReference,this.spatialReference);o&&await L(i.spatialReference,this.spatialReference);const l=typeof s=="number"?s:s.x,u=typeof s=="number"?s:s.y,c={xmin:i.x-l,xmax:i.x+l,ymin:i.y-u,ymax:i.y+u,spatialReference:i.spatialReference},h=o?C(c,this.spatialReference):c;if(!h)return{candidates:[]};const d=(await ce(he(i),null,{signal:t}))[0],m=(await ce(he(h),null,{signal:t}))[0];if(z(d)||z(m))return{candidates:[]};let f=new R(this._searchFeatures(this._getQueryBBoxes(m.toJSON())),null,this);f=await this._reschedule(()=>f.executeObjectIdsQuery(a),t),f=await this._reschedule(()=>f.executeTimeQuery(a),t),f=await this._reschedule(()=>f.executeAttributesQuery(a),t);const _=d.toJSON(),S=o?C(_,this.spatialReference):_,w=o?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return f.createSnappingResponse(re(Y({},e),{point:S,distance:w}),i.spatialReference)}async executeQueryForLatestObservations(e={},t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new F(Q,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});let i,s=Z(e);try{s=await this._schedule(()=>k(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t),i=await this._reschedule(()=>i.filterLatest(),t)}catch(r){if(r!==V)throw r;i=new R([],null,this)}return i.createQueryResponse(s)}async executeQueryForSummaryStatistics(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createSummaryStatisticsResponse(e,t)}async executeQueryForUniqueValues(e={},t,i){const{field:s,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:s,valueExpression:r},i)).createUniqueValuesResponse(e,t)}async executeQueryForClassBreaks(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createClassBreaksResponse(e,t)}async executeQueryForHistogram(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createHistogramResponse(e,t)}async _schedule(e,t){return j(this._frameTask)?this._frameTask.schedule(e,t):e(ze)}async _reschedule(e,t){return j(this._frameTask)?this._frameTask.reschedule(e,t):e(ze)}_getAll(){if(!this._allItems){const e=[];this.featureStore.forEach(t=>e.push(t)),this._allItems=new R(e,null,this)}return this._allItems}async _executeGeometryQuery(e,t){const{geometry:i,outSR:s,spatialRel:r,returnGeometry:a,returnCentroid:o}=e,l=this.featureStore.featureSpatialReference,u=i&&l&&l!==i.spatialReference?C(i,l):i,c=a||o,h=J(s)&&!D(this.spatialReference,s),d=this._geometryQueryCache?h&&c?JSON.stringify({originalFilterGeometry:i,spatialRelationship:r,outSpatialReference:s}):JSON.stringify({originalFilterGeometry:i,spatialRelationship:r}):null;if(d){const p=this._geometryQueryCache.get(d);if(!Vt(p))return p}const m=async p=>{if(h&&c){const x=await p.project(s);return d&&this._geometryQueryCache.put(d,x,x.size||1),x}return d&&this._geometryQueryCache.put(d,p,p.size||1),p};if(!u)return m(this._getAll());const f=this.featureAdapter;if(r==="esriSpatialRelDisjoint"){const p=this._searchFeatures(this._getQueryBBoxes(i));if(!p.length)return m(this._getAll());let x,I;const y=new Set;for(const b of p)y.add(f.getObjectId(b));await this._reschedule(()=>{let b=0;x=new Array(y.size),this.featureStore.forEach(T=>x[b++]=T),I=y},t);const g=await this._reschedule(async()=>{const b=await Pe(r,u,this.geometryType,this.hasZ,this.hasM),T=N=>!I.has(f.getObjectId(N))||b(f.getGeometry(N));return new R(await this._runSpatialFilter(x,T,t),i,this)},t);return m(g)}const _=this._searchFeatures(this._getQueryBBoxes(i));if(!_.length){const p=new R([],i,this);return d&&this._geometryQueryCache.put(d,p,p.size||1),p}if(this._canExecuteSoloPass(u,e))return m(new R(_,i,this));const S=await Pe(r,u,this.geometryType,this.hasZ,this.hasM),w=await this._runSpatialFilter(_,p=>S(f.getGeometry(p)),t);return m(new R(w,i,this))}async _runSpatialFilter(e,t,i){if(!t)return e;if(z(this._frameTask))return e.filter(o=>t(o));let s=0;const r=new Array,a=async o=>{for(;s<e.length;){const l=e[s++];t(l)&&(r.push(l),o.madeProgress()),o.done&&await this._reschedule(u=>a(u),i)}};return this._reschedule(o=>a(o),i).then(()=>r)}_canExecuteSoloPass(e,t){const{geometryType:i}=this,{spatialRel:s}=t;return De(e)&&(s==="esriSpatialRelEnvelopeIntersects"||i==="esriGeometryPoint"&&(s==="esriSpatialRelIntersects"||s==="esriSpatialRelContains"||s==="esriSpatialRelWithin"))}_getQueryBBoxes(e){if(De(e)){if(W(e))return[$e(e.xmin,e.ymin,e.xmax,e.ymax)];if(se(e))return e.rings.map(t=>$e(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1])))}return[Gt(Ct(),e)]}_searchFeatures(e){for(const s of e)this.featureStore.forEachInBounds(s,r=>{ie.add(r)});const t=new Array(ie.size);let i=0;return ie.forEach(s=>t[i++]=s),ie.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new F(Q,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsParamsSupport(t),Ne(e,this.geometryType,this.spatialReference),L(this.spatialReference,e.outSR)]).then(()=>e)}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:i}=await qe();t=i.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new F(Q,"params should have at least a field or valueExpression",{params:e});G(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new F(Q,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Ne(e,this.geometryType,this.spatialReference),L(this.spatialReference,e.outSR)]).then(()=>e)}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:i,returnDistinctValues:s,outStatistics:r}=e,a=r?r.map(o=>o.outStatisticFieldName&&o.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if(i&&i.length>0){const o=" asc",l=" desc",u=i.map(c=>{const h=c.toLowerCase();return h.indexOf(o)>-1?h.split(o)[0]:h.indexOf(l)>-1?h.split(l)[0]:c}).filter(c=>a.indexOf(c)===-1);G(this.fieldsIndex,u,"orderByFields contains missing fields")}if(t&&t.length>0)G(this.fieldsIndex,t,"outFields contains missing fields");else if(s)throw new F(Q,"outFields should be specified for returnDistinctValues",{query:e});Kt(this.fieldsIndex,e.where)}async _checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:i,having:s}=e,r=i&&i.length,a=t&&t.length;if(s){if(!r||!a)throw new F(Q,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});ei(this.fieldsIndex,s,t)}if(a){if(!bi(t))return;const o=t.map(l=>l.onStatisticField).filter(Boolean);G(this.fieldsIndex,o,"onStatisticFields contains missing fields"),r&&G(this.fieldsIndex,i,"groupByFieldsForStatistics contains missing fields");for(const l of t){const{onStatisticField:u,statisticType:c}=l;if((c==="percentile_disc"||c==="percentile_cont")&&"statisticParameters"in l){const{statisticParameters:h}=l;if(!h)throw new F(Q,"statisticParamters should be set for percentile type",{definition:l,query:e})}else if(c!=="count"&&u&&ii(u,this.fieldsIndex))throw new F(Q,"outStatistics contains non-numeric fields",{definition:l,query:e})}}}async _getQueryEngineResultForStats(e={},t,i){let s;e=Z(e);try{e=await this._schedule(()=>k(e,this.definitionExpression,this.spatialReference),i),e=await this._reschedule(()=>this._checkStatisticsSupport(e,t),i),s=await this._reschedule(()=>this._executeGeometryQuery(e,i),i),s=await this._reschedule(()=>s.executeAggregateIdsQuery(e),i),s=await this._reschedule(()=>s.executeObjectIdsQuery(e),i),s=await this._reschedule(()=>s.executeTimeQuery(e),i),s=await this._reschedule(()=>s.executeAttributesQuery(e),i)}catch(r){if(r!==V)throw r;s=new R([],null,this)}return s}}const Ti=Be(),A=Be();export{Ci as V,ci as Z,L as f,C as g,ri as n,Pe as v};
